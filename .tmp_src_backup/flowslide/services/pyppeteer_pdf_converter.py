"""
Playwright-based PDF converter for FlowSlide
Replaces the Pyppeteer implementation with Python Playwright for better stability and performance
"""

import asyncio
import logging
import os
import tempfile
import time
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

try:
    from playwright.async_api import Browser, BrowserContext, Page, async_playwright

    PLAYWRIGHT_AVAILABLE = True
except ImportError:
    PLAYWRIGHT_AVAILABLE = False

    # Create dummy types for type hints when playwright is not available
    class Browser:
        pass

    class Page:
        pass

    class BrowserContext:
        pass


logger = logging.getLogger(__name__)


class PlaywrightPDFConverter:
    """
    PDF converter using Playwright
    Optimized for 16:9 PPT slides with complete style preservation
    """

    def __init__(self):
        self.browser: Optional[Browser] = None
        self.context: Optional[BrowserContext] = None
        self.playwright = None
        self._browser_lock = asyncio.Lock()

    def is_available(self) -> bool:
        """Check if Playwright is available"""
        return PLAYWRIGHT_AVAILABLE

    @staticmethod
    def install_chromium():
        """ÊâãÂä®ÂÆâË£Ö Chromium ÁöÑËæÖÂä©ÊñπÊ≥ï"""
        if not PLAYWRIGHT_AVAILABLE:
            raise ImportError("Playwright is not available. Please install: pip install playwright")

        try:
            logger.info("üîÑ ÂºÄÂßãÊâãÂä®ÂÆâË£Ö Chromium...")

            # ÊñπÊ≥ï1: ‰ΩøÁî® playwright install ÂëΩ‰ª§
            try:
                import subprocess

                result = subprocess.run(
                    ["python", "-m", "playwright", "install", "chromium"],
                    capture_output=True,
                    text=True,
                    timeout=300,
                )

                if result.returncode == 0:
                    logger.info("‚úÖ Chromium ÈÄöËøá Playwright ÂÆâË£ÖÊàêÂäü")
                    return True
                else:
                    logger.warning(f"‚ö†Ô∏è Playwright ÂÆâË£ÖÂ§±Ë¥•: {result.stderr}")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Playwright ÂÆâË£ÖÂá∫Èîô: {e}")

            # ÊñπÊ≥ï2: Â∞ùËØïÂÆâË£ÖÊâÄÊúâÊµèËßàÂô®
            try:
                import subprocess

                result = subprocess.run(
                    ["python", "-m", "playwright", "install"],
                    capture_output=True,
                    text=True,
                    timeout=600,
                )

                if result.returncode == 0:
                    logger.info("‚úÖ ÊâÄÊúâÊµèËßàÂô®ÈÄöËøá Playwright ÂÆâË£ÖÊàêÂäü")
                    return True
                else:
                    logger.warning(f"‚ö†Ô∏è Playwright ÂÖ®ÈáèÂÆâË£ÖÂ§±Ë¥•: {result.stderr}")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Playwright ÂÖ®ÈáèÂÆâË£ÖÂá∫Èîô: {e}")

            return False

        except Exception as e:
            logger.error(f"‚ùå Chromium ÂÆâË£ÖÂ§±Ë¥•: {e}")
            return False

    async def _launch_browser(self) -> Browser:
        """Launch browser with enhanced settings optimized for chart rendering"""
        if not self.is_available():
            raise ImportError("Playwright is not available. Please install: pip install playwright")

        # Enhanced launch options with better Windows compatibility
        launch_args = [
            "--no-sandbox",
            "--disable-setuid-sandbox",
            "--disable-dev-shm-usage",
            "--disable-gpu",
            "--no-first-run",
            "--disable-extensions",
            "--disable-plugins",
            "--disable-background-timer-throttling",
            "--disable-backgrounding-occluded-windows",
            "--disable-renderer-backgrounding",
            "--run-all-compositor-stages-before-draw",
            "--disable-checker-imaging",
            # Additional stability options for Windows
            "--disable-web-security",
            "--disable-features=VizDisplayCompositor",
            "--disable-ipc-flooding-protection",
            "--disable-software-rasterizer",
            "--disable-background-networking",
            "--disable-default-apps",
            "--disable-sync",
            "--disable-translate",
            "--hide-scrollbars",
            "--metrics-recording-only",
            "--mute-audio",
            "--no-default-browser-check",
            "--no-pings",
            "--password-store=basic",
            "--use-mock-keychain",
            # Windows specific fixes
            "--disable-logging",
            "--disable-gpu-logging",
            "--disable-crash-reporter",
            "--disable-in-process-stack-traces",
            "--disable-breakpad",
            "--disable-component-extensions-with-background-pages",
            "--disable-client-side-phishing-detection",
            "--disable-hang-monitor",
            "--disable-prompt-on-repost",
            "--disable-domain-reliability",
            "--disable-component-update",
            "--no-service-autorun",
            "--disable-background-mode",
        ]

        try:
            # Initialize Playwright
            if self.playwright is None:
                self.playwright = await async_playwright().start()

            # Method 1: Try Playwright's installed Chromium first (especially for Docker)
            logger.info("üîÑ Trying Playwright's installed Chromium...")
            try:
                browser = await self.playwright.chromium.launch(headless=True, args=launch_args)
                logger.info("‚úÖ Playwright Chromium launched successfully")
                return browser

            except Exception as playwright_error:
                logger.warning(f"‚ùå Playwright Chromium launch failed: {playwright_error}")

            # Method 2: Try system Chrome with enhanced error handling
            system_chrome_paths = [
                "C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe",
                "C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe",
                "C:\\Users\\{}\\AppData\\Local\\Google\\Chrome\\Application\\chrome.exe".format(
                    os.environ.get("USERNAME", "")
                ),
                "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome",
                "/usr/bin/google-chrome",
                "/usr/bin/chromium-browser",
                "/snap/bin/chromium",
            ]

            for chrome_path in system_chrome_paths:
                if os.path.exists(chrome_path):
                    logger.info(f"üîç Found system Chrome at: {chrome_path}")

                    # Try different Chrome configurations
                    chrome_configs = [
                        # Config 1: Standard headless with custom executable
                        {
                            "executable_path": chrome_path,
                            "headless": True,
                            "args": [
                                "--no-sandbox",
                                "--disable-setuid-sandbox",
                                "--disable-dev-shm-usage",
                                "--disable-gpu",
                                "--disable-extensions",
                                "--disable-plugins",
                            ],
                        },
                        # Config 2: Minimal args
                        {
                            "executable_path": chrome_path,
                            "headless": True,
                            "args": ["--no-sandbox", "--disable-setuid-sandbox"],
                        },
                        # Config 3: No custom args
                        {"executable_path": chrome_path, "headless": True, "args": []},
                    ]

                    for config_idx, config in enumerate(chrome_configs):
                        try:
                            logger.info(f"üîÑ Â∞ùËØï Chrome ÈÖçÁΩÆ {config_idx + 1}/3")
                            browser = await self.playwright.chromium.launch(**config)
                            logger.info(f"‚úÖ Chrome ÂêØÂä®ÊàêÂäü (ÈÖçÁΩÆ {config_idx + 1})")
                            return browser

                        except Exception as e:
                            logger.warning(f"‚ùå Chrome ÈÖçÁΩÆ {config_idx + 1} Â§±Ë¥•: {e}")
                            if "ËøúÁ®ã‰∏ªÊú∫Âº∫Ëø´ÂÖ≥Èó≠" in str(e) or "Connection" in str(e):
                                # ÁΩëÁªúËøûÊé•ÈóÆÈ¢òÔºåÁ≠âÂæÖÂêéÈáçËØï
                                await asyncio.sleep(2)
                            continue

            # Method 3: Try portable Chrome
            logger.info("üîÑ System Chrome failed, trying portable solutions...")

            # Try to use any available Chrome-like browser
            portable_browsers = [
                "chrome.exe",  # Portable Chrome in current directory
                "chromium.exe",  # Portable Chromium
            ]

            for browser_exe in portable_browsers:
                if os.path.exists(browser_exe):
                    logger.info(f"üîç Found portable browser: {browser_exe}")
                    try:
                        portable_config = {
                            "executable_path": os.path.abspath(browser_exe),
                            "headless": True,
                            "args": ["--no-sandbox", "--disable-setuid-sandbox"],
                        }
                        browser = await self.playwright.chromium.launch(**portable_config)
                        logger.info(f"‚úÖ Portable browser launched: {browser_exe}")
                        return browser
                    except Exception as e:
                        logger.warning(f"‚ùå Portable browser failed: {e}")

            # Method 4: Final attempt with minimal config
            logger.info("üîÑ Final attempt with minimal configuration...")
            try:
                browser = await self.playwright.chromium.launch(
                    headless=True, args=["--no-sandbox"]  # Only essential arg
                )
                logger.info("‚úÖ Browser launched with minimal configuration")
                return browser

            except Exception as minimal_error:
                logger.error(f"‚ùå Minimal launch also failed: {minimal_error}")

        except Exception as e:
            logger.error(f"‚ùå All browser launch methods failed: {e}")

            # Provide comprehensive error message with solutions
            error_msg = (
                f"Êó†Ê≥ïÂêØÂä®ÊµèËßàÂô®: {e}\n\n"
                "Ëß£ÂÜ≥ÊñπÊ°à:\n"
                "1. Á°Æ‰øùÂ∑≤ÂÆâË£Ö Google Chrome ÊµèËßàÂô®\n"
                "2. ËøêË°å: pip install --upgrade playwright\n"
                "3. ÊâãÂä®ÂÆâË£Ö Chromium: python -m playwright install chromium\n"
                "4. ÊàñËÄÖÂÆâË£ÖÊâÄÊúâÊµèËßàÂô®: python -m playwright install\n"
                "5. Ê£ÄÊü•Èò≤ÁÅ´Â¢ôÂíåÊùÄÊØíËΩØ‰ª∂ÊòØÂê¶ÈòªÊ≠¢‰∫ÜÊµèËßàÂô®ÂêØÂä®"
            )
            raise ImportError(error_msg)

    async def _get_or_create_browser(self) -> Browser:
        """Get existing browser or create a new one (with thread safety)"""
        async with self._browser_lock:
            if self.browser is None:
                self.browser = await self._launch_browser()
                # Create a browser context for better isolation
                self.context = await self.browser.new_context(
                    viewport={"width": 1280, "height": 720},
                    device_scale_factor=2,
                    ignore_https_errors=True,
                )
            return self.browser

    async def _wait_for_charts_and_dynamic_content(self, page: Page, max_wait_time: int = 15000):
        """
        Enhanced function to wait for Chart.js, ECharts.js, D3.js charts and dynamic content to fully render
        Improved detection for multiple chart libraries and animations with extended wait time
        """
        logger.debug("üéØ Á≠âÂæÖÂõæË°®ÂíåÂä®ÊÄÅÂÜÖÂÆπÂÆåÂÖ®Ê∏≤Êüì...")

        start_time = time.time() * 1000  # Convert to milliseconds
        attempts = 0
        max_attempts = 30  # Ëøõ‰∏ÄÊ≠•Â¢ûÂä†Â∞ùËØïÊ¨°Êï∞‰ª•Á°Æ‰øùÊâÄÊúâÂä®ÊÄÅÂÜÖÂÆπÂÆåÂÖ®Âä†ËΩΩ

        # È¶ñÂÖàÁ≠âÂæÖÂü∫Á°ÄDOMÂíåËµÑÊ∫êÂä†ËΩΩ
        await page.wait_for_selector("body", timeout=5000)

        # Á≠âÂæÖÊâÄÊúâÂõæÁâáÂä†ËΩΩÂÆåÊàê
        await page.evaluate(
            """() => {
            return new Promise((resolve) => {
                const images = Array.from(document.querySelectorAll('img'));
                if (images.length === 0) {
                    resolve();
                    return;
                }

                let loadedCount = 0;
                const checkComplete = () => {
                    loadedCount++;
                    if (loadedCount === images.length) {
                        resolve();
                    }
                };

                images.forEach(img => {
                    if (img.complete) {
                        checkComplete();
                    } else {
                        img.onload = checkComplete;
                        img.onerror = checkComplete;
                    }
                });

                // Ë∂ÖÊó∂‰øùÊä§
                setTimeout(resolve, 3000);
            });
        }"""
        )

        while (time.time() * 1000 - start_time) < max_wait_time and attempts < max_attempts:
            attempts += 1

            try:
                # ËØ¶ÁªÜÊ£ÄÊü•È°µÈù¢Áä∂ÊÄÅÔºåÂåÖÊã¨Â§öÁßçÂõæË°®Â∫ìÁöÑÂä®ÊÄÅÂÜÖÂÆπ
                chart_status = await page.evaluate(
                    """() => {
                    const results = {
                        domReady: document.readyState === 'complete',
                        chartJsLoaded: typeof window.Chart !== 'undefined',
                        echartsLoaded: typeof window.echarts !== 'undefined',
                        d3Loaded: typeof window.d3 !== 'undefined',
                        canvasElements: 0,
                        svgElements: 0,
                        totalCharts: 0,
                        renderedCharts: 0,
                        echartsInstances: 0,
                        renderedEcharts: 0,
                        d3Elements: 0,
                        renderedD3: 0,
                        animationsComplete: true,
                        scriptsLoaded: true,
                        imagesLoaded: true
                    };

                    // Ê£ÄÊü•ÊâÄÊúâcanvasÂÖÉÁ¥†
                    const canvasElements = document.querySelectorAll('canvas');
                    results.canvasElements = canvasElements.length;

                    // Ê£ÄÊü•ÊâÄÊúâSVGÂÖÉÁ¥†
                    const svgElements = document.querySelectorAll('svg');
                    results.svgElements = svgElements.length;

                    // Ê£ÄÊü•ÂõæÁâáÊòØÂê¶ÂÖ®ÈÉ®Âä†ËΩΩÂÆåÊàê
                    const images = document.querySelectorAll('img');
                    images.forEach(img => {
                        if (!img.complete || img.naturalWidth === 0) {
                            results.imagesLoaded = false;
                        }
                    });

                    // Ê£ÄÊü•ËÑöÊú¨ÊòØÂê¶Âä†ËΩΩÂÆåÊàê
                    const scripts = document.querySelectorAll('script[src]');
                    scripts.forEach(script => {
                        if (script.readyState && script.readyState !== 'complete' && script.readyState !== 'loaded') {
                            results.scriptsLoaded = false;
                        }
                    });

                    // ËØ¶ÁªÜÊ£ÄÊü•Chart.jsÂÆû‰æãÂíåÊ∏≤ÊüìÁä∂ÊÄÅ
                    if (results.chartJsLoaded && window.Chart && window.Chart.instances) {
                        results.totalCharts = Object.keys(window.Chart.instances).length;

                        // Ê£ÄÊü•ÊØè‰∏™ÂõæË°®ÁöÑÊ∏≤ÊüìÁä∂ÊÄÅ
                        Object.values(window.Chart.instances).forEach(chart => {
                            if (chart && chart.canvas) {
                                try {
                                    const ctx = chart.canvas.getContext('2d');
                                    if (ctx) {
                                        // Ê£ÄÊü•canvasÊòØÂê¶ÊúâÂÆûÈôÖÂÜÖÂÆπ
                                        const imageData = ctx.getImageData(0, 0, Math.min(chart.canvas.width, 100), Math.min(chart.canvas.height, 100));
                                        let hasContent = false;

                                        // Ê£ÄÊü•Ââç100x100ÂÉèÁ¥†Âå∫ÂüüÊòØÂê¶ÊúâÈùûÈÄèÊòéÂÜÖÂÆπ
                                        for (let i = 3; i < imageData.data.length; i += 4) {
                                            if (imageData.data[i] > 0) { // alpha channel > 0
                                                hasContent = true;
                                                break;
                                            }
                                        }

                                        if (hasContent) {
                                            results.renderedCharts++;
                                        }
                                    }
                                } catch (e) {
                                    // Â¶ÇÊûúÊó†Ê≥ïÊ£ÄÊü•ÂÜÖÂÆπÔºåÂÅáËÆæÂ∑≤Ê∏≤Êüì
                                    results.renderedCharts++;
                                }

                                // Ê£ÄÊü•ÂõæË°®Âä®ÁîªÊòØÂê¶ÂÆåÊàê
                                if (chart.animating || (chart.options && chart.options.animation && chart.options.animation.duration > 0)) {
                                    results.animationsComplete = false;
                                }
                            }
                        });
                    }

                    // ËØ¶ÁªÜÊ£ÄÊü•EChartsÂÆû‰æãÂíåÊ∏≤ÊüìÁä∂ÊÄÅ
                    if (results.echartsLoaded && window.echarts) {
                        // Êü•ÊâæÊâÄÊúâEChartsÂÆû‰æã
                        document.querySelectorAll('[_echarts_instance_], [id*="chart"], [class*="chart"], [class*="echarts"]').forEach(el => {
                            const instance = window.echarts.getInstanceByDom(el);
                            if (instance) {
                                results.echartsInstances++;

                                try {
                                    // Ê£ÄÊü•EChartsÊòØÂê¶Â∑≤ÂÆåÊàêÊ∏≤Êüì
                                    const option = instance.getOption();
                                    if (option && option.series && option.series.length > 0) {
                                        // Ê£ÄÊü•canvasÂÜÖÂÆπ
                                        const canvas = el.querySelector('canvas');
                                        if (canvas) {
                                            const ctx = canvas.getContext('2d');
                                            if (ctx) {
                                                const imageData = ctx.getImageData(0, 0, Math.min(canvas.width, 100), Math.min(canvas.height, 100));
                                                let hasContent = false;

                                                for (let i = 3; i < imageData.data.length; i += 4) {
                                                    if (imageData.data[i] > 0) {
                                                        hasContent = true;
                                                        break;
                                                    }
                                                }

                                                if (hasContent) {
                                                    results.renderedEcharts++;
                                                }
                                            }
                                        } else {
                                            // Â¶ÇÊûúÊ≤°ÊúâcanvasÔºåÂÅáËÆæÂ∑≤Ê∏≤ÊüìÔºàÂèØËÉΩÊòØSVGÊ®°ÂºèÔºâ
                                            results.renderedEcharts++;
                                        }
                                    }

                                    // Ê£ÄÊü•EChartsÂä®ÁîªÁä∂ÊÄÅ
                                    if (option && option.animation !== false) {
                                        results.animationsComplete = false;
                                    }
                                } catch (e) {
                                    // Âá∫ÈîôÊó∂‰øùÂÆàÂ§ÑÁêÜÔºåÂÅáËÆæÂ∑≤Ê∏≤Êüì
                                    results.renderedEcharts++;
                                }
                            }
                        });
                    }

                    // ËØ¶ÁªÜÊ£ÄÊü•D3.js SVGÂÖÉÁ¥†ÂíåÊ∏≤ÊüìÁä∂ÊÄÅ
                    if (results.d3Loaded && window.d3) {
                        svgElements.forEach(svg => {
                            results.d3Elements++;

                            try {
                                // Ê£ÄÊü•SVGÊòØÂê¶ÊúâÂÆûÈôÖÂÜÖÂÆπ
                                const children = svg.children;
                                let hasContent = false;

                                // Ê£ÄÊü•ÊòØÂê¶ÊúâË∑ØÂæÑ„ÄÅÂúÜÂΩ¢„ÄÅÁü©ÂΩ¢Á≠âÂõæÂΩ¢ÂÖÉÁ¥†
                                const graphicElements = svg.querySelectorAll('path, circle, rect, line, polygon, polyline, ellipse, text, g');
                                if (graphicElements.length > 0) {
                                    // Ëøõ‰∏ÄÊ≠•Ê£ÄÊü•ÊòØÂê¶ÊúâÂÆûÈôÖÁöÑÁªòÂà∂ÂÜÖÂÆπ
                                    for (let elem of graphicElements) {
                                        const bbox = elem.getBBox ? elem.getBBox() : null;
                                        if (bbox && (bbox.width > 0 || bbox.height > 0)) {
                                            hasContent = true;
                                            break;
                                        }
                                        // Ê£ÄÊü•ÊòØÂê¶ÊúâÂ°´ÂÖÖÊàñÊèèËæπ
                                        const style = window.getComputedStyle(elem);
                                        if (style.fill !== 'none' || style.stroke !== 'none') {
                                            hasContent = true;
                                            break;
                                        }
                                    }
                                }

                                if (hasContent) {
                                    results.renderedD3++;
                                }
                            } catch (e) {
                                // Âá∫ÈîôÊó∂‰øùÂÆàÂ§ÑÁêÜÔºåÂÅáËÆæÂ∑≤Ê∏≤Êüì
                                results.renderedD3++;
                            }
                        });
                    }

                    // Ê£ÄÊü•ÂÖ∂‰ªñÂèØËÉΩÁöÑÂä®ÊÄÅÂÜÖÂÆπ
                    const dynamicElements = document.querySelectorAll('[class*="animate"], [class*="transition"], [style*="transition"], [style*="animation"]');
                    if (dynamicElements.length > 0) {
                        // ÁªôÂä®ÊÄÅÂÖÉÁ¥†‰∏Ä‰∫õÊó∂Èó¥ÂÆåÊàêÂä®Áîª
                        results.animationsComplete = false;
                    }

                    return results;
                }"""
                )

                logger.debug(
                    f"üìä ÂõæË°®Ê£ÄÊü• (Á¨¨{attempts}Ê¨°): DOM:{chart_status['domReady']}, Chart.js:{chart_status['renderedCharts']}/{chart_status['totalCharts']}, ECharts:{chart_status['renderedEcharts']}/{chart_status['echartsInstances']}, D3:{chart_status['renderedD3']}/{chart_status['d3Elements']}, Âä®Áîª:{chart_status['animationsComplete']}"
                )

                # Âà§Êñ≠ÊòØÂê¶ÊâÄÊúâÂÜÖÂÆπÈÉΩÂ∑≤ÂáÜÂ§áÂ∞±Áª™
                all_charts_ready = (
                    (
                        chart_status["totalCharts"] == 0
                        or chart_status["renderedCharts"] >= chart_status["totalCharts"]
                    )
                    and (
                        chart_status["echartsInstances"] == 0
                        or chart_status["renderedEcharts"] >= chart_status["echartsInstances"]
                    )
                    and (
                        chart_status["d3Elements"] == 0
                        or chart_status["renderedD3"] >= chart_status["d3Elements"]
                    )
                )

                all_ready = (
                    chart_status["domReady"]
                    and chart_status["scriptsLoaded"]
                    and chart_status["imagesLoaded"]
                    and chart_status["animationsComplete"]
                    and all_charts_ready
                )

                if all_ready:
                    logger.debug("‚úÖ ÊâÄÊúâÂõæË°®ÂíåÂä®ÊÄÅÂÜÖÂÆπÂ∑≤ÂÆåÂÖ®Ê∏≤Êüì")
                    break

                # Âä®ÊÄÅÁ≠âÂæÖÊó∂Èó¥ÔºöÂ¶ÇÊûúÊúâÂõæË°®ÂÜÖÂÆπÔºåÁ≠âÂæÖÊó∂Èó¥Êõ¥Áü≠
                total_rendered = (
                    chart_status["renderedCharts"]
                    + chart_status["renderedEcharts"]
                    + chart_status["renderedD3"]
                )
                total_expected = (
                    chart_status["totalCharts"]
                    + chart_status["echartsInstances"]
                    + chart_status["d3Elements"]
                )

                if total_rendered > 0 or total_expected == 0:
                    await asyncio.sleep(0.2)  # Â∑≤ÊúâÂÜÖÂÆπÔºåÂø´ÈÄüÊ£ÄÊü•
                else:
                    await asyncio.sleep(0.5)  # Á≠âÂæÖÂÜÖÂÆπÂä†ËΩΩ

            except Exception as error:
                logger.warning(f"‚ö†Ô∏è Ê∏≤ÊüìÊ£ÄÊü•Âá∫Èîô (Á¨¨{attempts}Ê¨°): {error}")
                await asyncio.sleep(0.5)

        # Ê†πÊçÆÊ£ÄÊµãÁªìÊûúÂÜ≥ÂÆöÊúÄÁªàÁ≠âÂæÖÊó∂Èó¥
        if attempts < 5:  # Â¶ÇÊûúÂæàÂø´Â∞±Ê£ÄÊµãÂà∞ÂÜÖÂÆπÂÆåÊàêÔºåÂè™ÈúÄÁü≠ÊöÇÁ≠âÂæÖ
            await asyncio.sleep(0.5)
        else:  # Â¶ÇÊûúÈúÄË¶ÅËæÉÈïøÊó∂Èó¥Ê£ÄÊµãÔºåÁªôÊõ¥Â§öÁ®≥ÂÆöÊó∂Èó¥
            await asyncio.sleep(1.2)

        # È¢ùÂ§ñÁöÑÁ®≥ÂÆöÁ≠âÂæÖÔºåÁ°Æ‰øùÊâÄÊúâÂºÇÊ≠•Ê∏≤ÊüìÂÆåÊàê
        logger.debug("üîÑ ÊâßË°åÊúÄÁªàÁ®≥ÂÆöÁ≠âÂæÖ...")
        await asyncio.sleep(1.0)

        # Âº∫Âà∂Ëß¶Âèë‰∏ÄÊ¨°ÈáçÊéíÂíåÈáçÁªò
        await page.evaluate(
            """() => {
            // Âº∫Âà∂ÈáçÊéí
            document.body.offsetHeight;

            // Ëß¶Âèëresize‰∫ã‰ª∂Á°Æ‰øùÊâÄÊúâÂìçÂ∫îÂºèÂÜÖÂÆπÊõ¥Êñ∞
            window.dispatchEvent(new Event('resize'));

            // Á≠âÂæÖ‰∏Ä‰∏™Ê∏≤ÊüìÂ∏ß
            return new Promise(resolve => {
                requestAnimationFrame(() => {
                    requestAnimationFrame(resolve);
                });
            });
        }"""
        )

        total_time = time.time() * 1000 - start_time
        logger.debug(f"‚ú® ÂõæË°®ÂíåÂä®ÊÄÅÂÜÖÂÆπÁ≠âÂæÖÂÆåÊàêÔºåÊÄªËÄóÊó∂: {total_time:.0f}ms")

    async def _perform_final_chart_verification(self, page: Page) -> Optional[Dict]:
        """Enhanced final verification for Chart.js, ECharts, and D3.js charts"""
        logger.debug("üîç ÊâßË°åÊúÄÁªàÂõæË°®Ê∏≤ÊüìÈ™åËØÅ...")

        try:
            final_status = await page.evaluate(
                """() => {
                const results = {
                    totalCanvasElements: 0,
                    renderedCanvasElements: 0,
                    chartInstances: 0,
                    echartsInstances: 0,
                    renderedEchartsInstances: 0,
                    svgElements: 0,
                    renderedSvgElements: 0,
                    d3Elements: 0,
                    renderedD3Elements: 0,
                    errors: [],
                    contentVerified: false
                };

                // Ê£ÄÊü•CanvasÂÖÉÁ¥†
                const canvasElements = document.querySelectorAll('canvas');
                results.totalCanvasElements = canvasElements.length;

                canvasElements.forEach((canvas, index) => {
                    try {
                        const ctx = canvas.getContext('2d');
                        if (ctx && canvas.width > 0 && canvas.height > 0) {
                            let hasContent = false;

                            try {
                                // ÊñπÊ≥ï1ÔºöÊ£ÄÊü•canvasÊï∞ÊçÆURLÔºàÈôç‰ΩéÈòàÂÄºÔºâ
                                const dataURL = canvas.toDataURL();
                                // Á©∫ÁôΩcanvasÁöÑdataURLÈÄöÂ∏∏ÂæàÁü≠ÔºåÈôç‰ΩéÈòàÂÄº‰ª•ÈÄÇÂ∫îÊõ¥Â§öÊÉÖÂÜµ
                                if (dataURL && dataURL.length > 500) {
                                    hasContent = true;
                                }
                            } catch (e) {
                                // Â¶ÇÊûútoDataURLÂ§±Ë¥•ÔºåÂ∞ùËØïÂÖ∂‰ªñÊñπÊ≥ï
                            }

                            if (!hasContent) {
                                try {
                                    // ÊñπÊ≥ï2ÔºöÊ£ÄÊü•ÂÉèÁ¥†Êï∞ÊçÆÔºàÊõ¥ÂÆΩÊùæÁöÑÊ£ÄÊµãÔºâ
                                    const sampleSize = Math.min(50, canvas.width, canvas.height);
                                    const imageData = ctx.getImageData(0, 0, sampleSize, sampleSize);

                                    // Ê£ÄÊü•ÊòØÂê¶Êúâ‰ªª‰ΩïÈùûÈÄèÊòéÂÉèÁ¥†ÔºàÊõ¥ÂÆΩÊùæÁöÑÊù°‰ª∂Ôºâ
                                    for (let i = 3; i < imageData.data.length; i += 4) {
                                        const a = imageData.data[i];
                                        // Âè™Ë¶ÅÊúâÈùûÈÄèÊòéÂÉèÁ¥†Â∞±ËÆ§‰∏∫ÊúâÂÜÖÂÆπ
                                        if (a > 0) {
                                            hasContent = true;
                                            break;
                                        }
                                    }

                                    // Â¶ÇÊûúÊ≤°ÊúâÈÄèÊòéÂ∫¶ÂèòÂåñÔºåÊ£ÄÊü•È¢úËâ≤ÂèòÂåñ
                                    if (!hasContent) {
                                        for (let i = 0; i < imageData.data.length; i += 4) {
                                            const r = imageData.data[i];
                                            const g = imageData.data[i + 1];
                                            const b = imageData.data[i + 2];

                                            // Ê£ÄÊü•ÊòØÂê¶Êúâ‰ªª‰ΩïÈ¢úËâ≤ÂèòÂåñÔºà‰∏çÈôê‰∫éÈùûÁôΩËâ≤Ôºâ
                                            if (r !== imageData.data[0] || g !== imageData.data[1] || b !== imageData.data[2]) {
                                                hasContent = true;
                                                break;
                                            }
                                        }
                                    }
                                } catch (e) {
                                    // Â¶ÇÊûúÂÉèÁ¥†Ê£ÄÊü•Â§±Ë¥•ÔºåÂÅáËÆæÊúâÂÜÖÂÆπÔºà‰øùÂÆàÂ§ÑÁêÜÔºâ
                                    hasContent = true;
                                }
                            }

                            // ÊñπÊ≥ï3ÔºöÊ£ÄÊü•ÊòØÂê¶ÂÖ≥ËÅî‰∫ÜChart.jsÂÆû‰æã
                            if (!hasContent && window.Chart && window.Chart.instances) {
                                Object.values(window.Chart.instances).forEach(chart => {
                                    if (chart && chart.canvas === canvas) {
                                        hasContent = true;
                                    }
                                });
                            }

                            // ÊñπÊ≥ï4ÔºöÊ£ÄÊü•ÊòØÂê¶ÂÖ≥ËÅî‰∫ÜEChartsÂÆû‰æã
                            if (!hasContent && window.echarts) {
                                const parentElement = canvas.parentElement;
                                if (parentElement) {
                                    const instance = window.echarts.getInstanceByDom(parentElement);
                                    if (instance) {
                                        hasContent = true;
                                    }
                                }
                            }

                            if (hasContent) {
                                results.renderedCanvasElements++;
                            }
                        }
                    } catch (e) {
                        results.errors.push(`Canvas ${index}: ${e.message}`);
                        // Âá∫ÈîôÊó∂‰øùÂÆàÂ§ÑÁêÜÔºåÂÅáËÆæÊúâÂÜÖÂÆπ
                        results.renderedCanvasElements++;
                    }
                });

                // Ê£ÄÊü•Chart.jsÂÆû‰æã
                if (window.Chart && window.Chart.instances) {
                    results.chartInstances = Object.keys(window.Chart.instances).length;
                }

                // ËØ¶ÁªÜÊ£ÄÊü•EChartsÂÆû‰æã
                if (window.echarts) {
                    document.querySelectorAll('[_echarts_instance_], [id*="chart"], [class*="chart"], [class*="echarts"]').forEach((el, index) => {
                        const instance = window.echarts.getInstanceByDom(el);
                        if (instance) {
                            results.echartsInstances++;

                            try {
                                // Ê£ÄÊü•EChartsÊòØÂê¶ÊúâÊúâÊïàÁöÑÈÖçÁΩÆÂíåÊï∞ÊçÆ
                                const option = instance.getOption();
                                if (option && option.series && option.series.length > 0) {
                                    let hasValidData = false;

                                    // Ê£ÄÊü•Á≥ªÂàóÊï∞ÊçÆ
                                    option.series.forEach(series => {
                                        if (series.data && series.data.length > 0) {
                                            hasValidData = true;
                                        }
                                    });

                                    if (hasValidData) {
                                        // Ê£ÄÊü•Ê∏≤ÊüìÁöÑcanvasÊàñSVGÂÜÖÂÆπ
                                        const canvas = el.querySelector('canvas');
                                        const svg = el.querySelector('svg');
                                        let contentRendered = false;

                                        if (canvas) {
                                            try {
                                                const ctx = canvas.getContext('2d');
                                                if (ctx && canvas.width > 0 && canvas.height > 0) {
                                                    // Ê£ÄÊü•canvasÊï∞ÊçÆURL
                                                    const dataURL = canvas.toDataURL();
                                                    if (dataURL && dataURL.length > 500) {
                                                        contentRendered = true;
                                                    } else {
                                                        // Ê£ÄÊü•ÂÉèÁ¥†Êï∞ÊçÆ
                                                        const imageData = ctx.getImageData(0, 0, Math.min(canvas.width, 30), Math.min(canvas.height, 30));
                                                        for (let i = 3; i < imageData.data.length; i += 4) {
                                                            if (imageData.data[i] > 0) {
                                                                contentRendered = true;
                                                                break;
                                                            }
                                                        }
                                                    }
                                                }
                                            } catch (e) {
                                                // canvasÊ£ÄÊü•Â§±Ë¥•ÔºåÂÅáËÆæÂ∑≤Ê∏≤Êüì
                                                contentRendered = true;
                                            }
                                        } else if (svg) {
                                            const graphicElements = svg.querySelectorAll('path, circle, rect, line, polygon, text, g');
                                            if (graphicElements.length > 0) {
                                                contentRendered = true;
                                            }
                                        } else {
                                            // Â¶ÇÊûúÊâæ‰∏çÂà∞canvasÊàñsvgÔºå‰ΩÜÊúâÊï∞ÊçÆÂíåÈÖçÁΩÆÔºåÂÅáËÆæÂ∑≤Ê∏≤Êüì
                                            contentRendered = true;
                                        }

                                        if (contentRendered) {
                                            results.renderedEchartsInstances++;
                                        }
                                    } else {
                                        // Âç≥‰ΩøÊ≤°ÊúâÊï∞ÊçÆÔºåÂ¶ÇÊûúÊúâÈÖçÁΩÆ‰πüÂèØËÉΩÊòØÊúâÊïàÁöÑÂõæË°®
                                        results.renderedEchartsInstances++;
                                    }
                                }
                            } catch (e) {
                                results.errors.push(`ECharts ${index}: ${e.message}`);
                                // Âá∫ÈîôÊó∂‰øùÂÆàÂ§ÑÁêÜÔºåÂÅáËÆæÂ∑≤Ê∏≤Êüì
                                results.renderedEchartsInstances++;
                            }
                        }
                    });
                }

                // ËØ¶ÁªÜÊ£ÄÊü•SVGÂÖÉÁ¥†Ôºà‰∏ªË¶ÅÈíàÂØπD3.jsÔºâ
                const svgElements = document.querySelectorAll('svg');
                results.svgElements = svgElements.length;

                svgElements.forEach((svg, index) => {
                    try {
                        // Ê£ÄÊü•SVGÊòØÂê¶ÊúâÂÆûÈôÖÁöÑÂõæÂΩ¢ÂÜÖÂÆπ
                        const graphicElements = svg.querySelectorAll('path, circle, rect, line, polygon, polyline, ellipse, text, g');
                        let hasContent = false;

                        if (graphicElements.length > 0) {
                            // Ê£ÄÊü•ÂõæÂΩ¢ÂÖÉÁ¥†ÊòØÂê¶ÊúâÂÆûÈôÖÁöÑÂ∞∫ÂØ∏ÂíåÊ†∑Âºè
                            for (let elem of graphicElements) {
                                try {
                                    const bbox = elem.getBBox ? elem.getBBox() : null;
                                    if (bbox && (bbox.width > 0 || bbox.height > 0)) {
                                        hasContent = true;
                                        break;
                                    }

                                    // Ê£ÄÊü•ÊòØÂê¶ÊúâÂ°´ÂÖÖÊàñÊèèËæπ
                                    const style = window.getComputedStyle(elem);
                                    if ((style.fill && style.fill !== 'none') || (style.stroke && style.stroke !== 'none')) {
                                        hasContent = true;
                                        break;
                                    }

                                    // Ê£ÄÊü•ÂÜÖËÅîÊ†∑Âºè
                                    if (elem.getAttribute('fill') || elem.getAttribute('stroke')) {
                                        hasContent = true;
                                        break;
                                    }
                                } catch (e) {
                                    // Âçï‰∏™ÂÖÉÁ¥†Ê£ÄÊü•Â§±Ë¥•ÔºåÁªßÁª≠Ê£ÄÊü•ÂÖ∂‰ªñÂÖÉÁ¥†
                                    continue;
                                }
                            }
                        }

                        if (hasContent) {
                            results.renderedSvgElements++;

                            // Â¶ÇÊûúËøô‰∏™SVGÁúãËµ∑Êù•ÂÉèD3.jsÂàõÂª∫ÁöÑÔºåËÆ°ÂÖ•D3ÂÖÉÁ¥†
                            if (svg.classList.contains('d3') ||
                                svg.getAttribute('class')?.includes('d3') ||
                                svg.querySelector('[class*="d3"]') ||
                                window.d3) {
                                results.d3Elements++;
                                results.renderedD3Elements++;
                            }
                        }
                    } catch (e) {
                        results.errors.push(`SVG ${index}: ${e.message}`);
                        // Âá∫ÈîôÊó∂‰øùÂÆàÂ§ÑÁêÜÔºåÂÅáËÆæÊúâÂÜÖÂÆπ
                        results.renderedSvgElements++;
                        if (window.d3) {
                            results.d3Elements++;
                            results.renderedD3Elements++;
                        }
                    }
                });

                // Â¶ÇÊûúÊ≤°ÊúâÊòéÁ°ÆÁöÑD3Ê†áËØÜÔºå‰ΩÜÊúâD3Â∫ì‰∏îÊúâSVGÔºåÂ∞ÜÊâÄÊúâSVGËßÜ‰∏∫ÊΩúÂú®ÁöÑD3ÂÖÉÁ¥†
                if (window.d3 && results.d3Elements === 0 && results.svgElements > 0) {
                    results.d3Elements = results.svgElements;
                    results.renderedD3Elements = results.renderedSvgElements;
                }

                // Êô∫ËÉΩÈ™åËØÅÂÜÖÂÆπÊòØÂê¶ÂÖÖÂàÜÊ∏≤Êüì
                const totalRendered = results.renderedCanvasElements + results.renderedEchartsInstances + results.renderedSvgElements;
                const totalExpected = results.totalCanvasElements + results.echartsInstances + results.svgElements;

                // Êõ¥Êô∫ËÉΩÁöÑÈ™åËØÅÈÄªËæë
                let contentVerified = false;

                if (totalExpected === 0) {
                    // Â¶ÇÊûúÊ≤°ÊúâÂõæË°®ÂÖÉÁ¥†ÔºåËÆ§‰∏∫È™åËØÅÈÄöËøá
                    contentVerified = true;
                } else if (totalRendered >= totalExpected * 0.6) {
                    // Èôç‰ΩéÈòàÂÄºÂà∞60%ÔºåÊõ¥ÂÆΩÊùæÁöÑÈ™åËØÅ
                    contentVerified = true;
                } else if (results.chartInstances > 0 || results.echartsInstances > 0 || results.svgElements > 0) {
                    // Â¶ÇÊûúÊúâÂõæË°®Â∫ìÂÆû‰æãÊàñSVGÂÖÉÁ¥†ÔºåÂç≥‰ΩøÊ£ÄÊµã‰∏çÂÆåÁæé‰πüËÆ§‰∏∫ÂèØËÉΩÂ∑≤Ê∏≤Êüì
                    contentVerified = true;
                } else if (totalRendered > 0) {
                    // Âè™Ë¶ÅÊúâ‰ªª‰ΩïÊ∏≤ÊüìÂÜÖÂÆπÂ∞±ËÆ§‰∏∫ÈÉ®ÂàÜÊàêÂäü
                    contentVerified = true;
                }

                results.contentVerified = contentVerified;

                return results;
            }"""
            )

            # ËÆ°ÁÆóÊ∏≤ÊüìÁªüËÆ°
            total_rendered = (
                final_status["renderedCanvasElements"]
                + final_status["renderedEchartsInstances"]
                + final_status["renderedSvgElements"]
            )
            total_expected = (
                final_status["totalCanvasElements"]
                + final_status["echartsInstances"]
                + final_status["svgElements"]
            )
            render_percentage = (
                (total_rendered / total_expected * 100) if total_expected > 0 else 100
            )

            logger.debug(
                f"üìä ÊúÄÁªàÈ™åËØÅÁªìÊûú: Canvas:{final_status['renderedCanvasElements']}/{final_status['totalCanvasElements']}, Chart.js:{final_status['chartInstances']}, ECharts:{final_status['renderedEchartsInstances']}/{final_status['echartsInstances']}, SVG:{final_status['renderedSvgElements']}/{final_status['svgElements']}, D3:{final_status['renderedD3Elements']}/{final_status['d3Elements']}"
            )
            logger.debug(
                f"üìà Ê∏≤ÊüìÂÆåÊàêÂ∫¶: {render_percentage:.1f}% ({total_rendered}/{total_expected})"
            )

            if final_status["errors"]:
                logger.debug(f"‚ö†Ô∏è È™åËØÅ‰∏≠ÂèëÁé∞ÈîôËØØ: {final_status['errors'][:3]}")  # Âè™ÊòæÁ§∫Ââç3‰∏™ÈîôËØØ

            if not final_status["contentVerified"]:
                logger.info(
                    f"‚ö†Ô∏è ÂõæË°®Ê∏≤ÊüìÊ£ÄÊµã: {render_percentage:.1f}%ÂÆåÊàê ({total_rendered}/{total_expected})Ôºå‰ΩÜPDFÁîüÊàêÂ∞ÜÁªßÁª≠"
                )
            else:
                logger.debug(f"‚úÖ ÂõæË°®ÂÜÖÂÆπÈ™åËØÅÈÄöËøá: {render_percentage:.1f}%Ê∏≤ÊüìÂÆåÊàê")

            return final_status

        except Exception as error:
            logger.error(f"‚ùå ÊúÄÁªàÂõæË°®È™åËØÅÂ§±Ë¥•: {error}")
            # ËøîÂõû‰∏Ä‰∏™Âü∫Á°ÄÁöÑÈ™åËØÅÁªìÊûúÔºåÂÅáËÆæÂÜÖÂÆπÂ∑≤Ê∏≤Êüì
            return {
                "totalCanvasElements": 0,
                "renderedCanvasElements": 0,
                "chartInstances": 0,
                "echartsInstances": 0,
                "renderedEchartsInstances": 0,
                "svgElements": 0,
                "renderedSvgElements": 0,
                "d3Elements": 0,
                "renderedD3Elements": 0,
                "errors": [f"È™åËØÅÂ§±Ë¥•: {error}"],
                "contentVerified": True,  # È™åËØÅÂ§±Ë¥•Êó∂‰øùÂÆàÂ§ÑÁêÜÔºåÂÅáËÆæÂ∑≤Ê∏≤Êüì
            }

    async def _force_chart_initialization(self, page: Page):
        """Enhanced chart initialization for Chart.js, ECharts, and D3.js"""
        logger.debug("üé® Âº∫Âà∂ÂàùÂßãÂåñÂíåËß¶ÂèëÂõæË°®Ê∏≤Êüì...")

        try:
            # Á¨¨‰∏ÄÊ≠•ÔºöÊü•ÊâæÂπ∂ÈáçÊñ∞ÊâßË°åÂõæË°®Áõ∏ÂÖ≥ËÑöÊú¨
            script_count = await page.evaluate(
                """() => {
                // Êü•ÊâæÊâÄÊúâÂèØËÉΩÂåÖÂê´ÂõæË°®ÈÖçÁΩÆÁöÑscriptÊ†áÁ≠æ
                const scripts = document.querySelectorAll('script');
                const chartScripts = [];

                scripts.forEach(script => {
                    if (script.textContent && (
                        script.textContent.includes('Chart') ||
                        script.textContent.includes('chart') ||
                        script.textContent.includes('new Chart') ||
                        script.textContent.includes('echarts') ||
                        script.textContent.includes('d3') ||
                        script.textContent.includes('plotly') ||
                        script.textContent.includes('setOption') ||
                        script.textContent.includes('select(') ||
                        script.textContent.includes('append(')
                    )) {
                        chartScripts.push(script.textContent);
                    }
                });

                // ÈáçÊñ∞ÊâßË°åÂõæË°®Áõ∏ÂÖ≥ÁöÑËÑöÊú¨
                chartScripts.forEach((scriptContent, index) => {
                    try {
                        console.log(`ÈáçÊñ∞ÊâßË°åÂõæË°®ËÑöÊú¨ ${index + 1}/${chartScripts.length}`);
                        eval(scriptContent);
                    } catch (e) {
                        console.warn(`ÂõæË°®ËÑöÊú¨ ${index + 1} ÊâßË°åÂ§±Ë¥•:`, e.message);
                    }
                });

                return chartScripts.length;
            }"""
            )

            logger.debug(f"üîÑ ÈáçÊñ∞ÊâßË°å‰∫Ü {script_count} ‰∏™ÂõæË°®Áõ∏ÂÖ≥ËÑöÊú¨")

            # Á≠âÂæÖËÑöÊú¨ÊâßË°å
            await asyncio.sleep(0.5)

            # Á¨¨‰∫åÊ≠•ÔºöÂº∫Âà∂Ëß¶ÂèëÂõæË°®Ê∏≤ÊüìÂíåÊõ¥Êñ∞
            chart_results = await page.evaluate(
                """() => {
                const results = {
                    chartJsProcessed: 0,
                    echartsProcessed: 0,
                    d3Processed: 0,
                    errors: []
                };

                // Chart.js Â§ÑÁêÜ
                if (window.Chart && window.Chart.instances) {
                    Object.values(window.Chart.instances).forEach((chart, index) => {
                        try {
                            if (chart) {
                                // Á¶ÅÁî®Âä®Áîª‰ª•Âä†Âø´Ê∏≤Êüì
                                if (chart.options) {
                                    if (chart.options.animation) {
                                        chart.options.animation.duration = 0;
                                        chart.options.animation.animateRotate = false;
                                        chart.options.animation.animateScale = false;
                                    }
                                    if (chart.options.plugins && chart.options.plugins.legend) {
                                        chart.options.plugins.legend.animation = false;
                                    }
                                }

                                // Âº∫Âà∂Ê∏≤Êüì
                                if (typeof chart.render === 'function') {
                                    chart.render();
                                }

                                // Êó†Âä®ÁîªÊõ¥Êñ∞
                                if (typeof chart.update === 'function') {
                                    chart.update('none');
                                }

                                // Âº∫Âà∂ÈáçÁªò
                                if (typeof chart.draw === 'function') {
                                    chart.draw();
                                }

                                results.chartJsProcessed++;
                                console.log(`Â§ÑÁêÜChart.jsÂõæË°® ${index + 1}`);
                            }
                        } catch (e) {
                            results.errors.push(`Chart.jsÂõæË°® ${index + 1}: ${e.message}`);
                            console.warn(`Chart.jsÂõæË°® ${index + 1} Â§ÑÁêÜÂ§±Ë¥•:`, e.message);
                        }
                    });
                }

                // ECharts Â§ÑÁêÜ
                if (window.echarts) {
                    const charts = [];
                    // Êü•ÊâæÊâÄÊúâÂèØËÉΩÁöÑEChartsÂÆπÂô®
                    document.querySelectorAll('[id*="chart"], [class*="chart"], [class*="echarts"], [_echarts_instance_]').forEach(el => {
                        const instance = window.echarts.getInstanceByDom(el);
                        if (instance) {
                            charts.push({instance, element: el});
                        }
                    });

                    charts.forEach(({instance, element}, index) => {
                        try {
                            // Ëé∑ÂèñÂΩìÂâçÈÖçÁΩÆ
                            const option = instance.getOption();

                            if (option) {
                                // Á¶ÅÁî®Âä®Áîª
                                const newOption = JSON.parse(JSON.stringify(option));
                                newOption.animation = false;

                                if (newOption.series) {
                                    if (Array.isArray(newOption.series)) {
                                        newOption.series.forEach(s => {
                                            s.animation = false;
                                            s.animationDuration = 0;
                                        });
                                    } else {
                                        newOption.series.animation = false;
                                        newOption.series.animationDuration = 0;
                                    }
                                }

                                // ÈáçÊñ∞ËÆæÁΩÆÈÖçÁΩÆ
                                instance.setOption(newOption, true);
                            }

                            // Âº∫Âà∂Ë∞ÉÊï¥Â§ßÂ∞è
                            instance.resize();

                            // Âº∫Âà∂ÈáçÁªò
                            if (typeof instance.refresh === 'function') {
                                instance.refresh();
                            }

                            results.echartsProcessed++;
                            console.log(`Â§ÑÁêÜEChartsÂõæË°® ${index + 1}`);
                        } catch (e) {
                            results.errors.push(`EChartsÂõæË°® ${index + 1}: ${e.message}`);
                            console.warn(`EChartsÂõæË°® ${index + 1} Â§ÑÁêÜÂ§±Ë¥•:`, e.message);
                        }
                    });
                }

                // D3.js Â§ÑÁêÜ - Ëß¶ÂèëÈáçÁªòÂíåÊõ¥Êñ∞
                if (window.d3) {
                    const svgElements = document.querySelectorAll('svg');
                    svgElements.forEach((svg, index) => {
                        try {
                            // Ëß¶ÂèëÂ§öÁßç‰∫ã‰ª∂Êù•Á°Æ‰øùD3ÂõæË°®ÈáçÁªò
                            const events = ['resize', 'load', 'DOMContentLoaded'];
                            events.forEach(eventType => {
                                const event = new Event(eventType);
                                svg.dispatchEvent(event);
                                if (svg.parentElement) {
                                    svg.parentElement.dispatchEvent(event);
                                }
                            });

                            // Âº∫Âà∂ÈáçÊñ∞ËÆ°ÁÆóSVGÂ∞∫ÂØ∏
                            const bbox = svg.getBBox();
                            if (bbox.width === 0 || bbox.height === 0) {
                                // Â¶ÇÊûúSVGÊ≤°ÊúâÂÜÖÂÆπÔºåÂ∞ùËØïËß¶ÂèëÈáçÁªò
                                svg.style.display = 'none';
                                svg.offsetHeight; // Âº∫Âà∂ÈáçÊéí
                                svg.style.display = '';
                            }

                            // Â¶ÇÊûúSVGÊúâD3Áõ∏ÂÖ≥ÁöÑÁ±ªÊàñÂ±ûÊÄßÔºåÂ∞ùËØïË∞ÉÁî®D3ÁöÑÊõ¥Êñ∞ÊñπÊ≥ï
                            if (svg.__data__ || svg.classList.contains('d3') || svg.getAttribute('class')?.includes('d3')) {
                                // Â∞ùËØïËß¶ÂèëD3ÁöÑtransitionÂÆåÊàê
                                if (window.d3.select) {
                                    const selection = window.d3.select(svg);
                                    if (selection.interrupt) {
                                        selection.interrupt();
                                    }
                                }
                            }

                            results.d3Processed++;
                            console.log(`Â§ÑÁêÜD3.js SVG ${index + 1}`);
                        } catch (e) {
                            results.errors.push(`D3.js SVG ${index + 1}: ${e.message}`);
                            console.warn(`D3.js SVG ${index + 1} Â§ÑÁêÜÂ§±Ë¥•:`, e.message);
                        }
                    });
                }

                // ÈÄöÁî®Â§ÑÁêÜÔºöËß¶ÂèëÁ™óÂè£‰∫ã‰ª∂
                try {
                    window.dispatchEvent(new Event('resize'));
                    window.dispatchEvent(new Event('load'));
                    window.dispatchEvent(new Event('DOMContentLoaded'));

                    // Âº∫Âà∂ÈáçÊéíÂíåÈáçÁªò
                    document.body.offsetHeight;

                    // Ëß¶ÂèëÊâÄÊúâÂèØËÉΩÁöÑÂõæË°®ÂÆπÂô®ÁöÑresize‰∫ã‰ª∂
                    document.querySelectorAll('[id*="chart"], [class*="chart"]').forEach(el => {
                        el.dispatchEvent(new Event('resize'));
                    });
                } catch (e) {
                    results.errors.push(`ÈÄöÁî®‰∫ã‰ª∂Ëß¶ÂèëÂ§±Ë¥•: ${e.message}`);
                }

                return results;
            }"""
            )

            logger.debug(
                f"‚úÖ ÂõæË°®Âº∫Âà∂ÂàùÂßãÂåñÂÆåÊàê: Chart.js:{chart_results['chartJsProcessed']}, ECharts:{chart_results['echartsProcessed']}, D3:{chart_results['d3Processed']}"
            )

            if chart_results["errors"]:
                logger.debug(f"‚ö†Ô∏è ÂàùÂßãÂåñËøáÁ®ã‰∏≠ÁöÑÈîôËØØ: {chart_results['errors']}")

        except Exception as error:
            logger.debug(f"‚ö†Ô∏è ÂõæË°®Âº∫Âà∂ÂàùÂßãÂåñÂ§±Ë¥•: {error}")

    async def _wait_for_fonts_and_resources(self, page: Page, max_wait_time: int = 8000):
        """Á≠âÂæÖÊâÄÊúâÂ≠ó‰ΩìÂíåÂ§ñÈÉ®ËµÑÊ∫êÂä†ËΩΩÂÆåÊàê"""
        logger.debug("üî§ Á≠âÂæÖÂ≠ó‰ΩìÂíåÂ§ñÈÉ®ËµÑÊ∫êÂä†ËΩΩ...")

        start_time = time.time() * 1000

        try:
            # Á≠âÂæÖÂ≠ó‰ΩìÂä†ËΩΩÂÆåÊàê
            await page.evaluate(
                """() => {
                return new Promise((resolve) => {
                    if (document.fonts && document.fonts.ready) {
                        document.fonts.ready.then(resolve);
                        // Ë∂ÖÊó∂‰øùÊä§
                        setTimeout(resolve, 5000);
                    } else {
                        // Â¶ÇÊûú‰∏çÊîØÊåÅ document.fontsÔºåÁ≠âÂæÖ‰∏ÄÊÆµÊó∂Èó¥
                        setTimeout(resolve, 2000);
                    }
                });
            }"""
            )

            # Á≠âÂæÖÊâÄÊúâÊ†∑ÂºèË°®Âä†ËΩΩÂÆåÊàê
            await page.evaluate(
                """() => {
                return new Promise((resolve) => {
                    const stylesheets = Array.from(document.styleSheets);
                    let loadedCount = 0;

                    if (stylesheets.length === 0) {
                        resolve();
                        return;
                    }

                    const checkComplete = () => {
                        loadedCount++;
                        if (loadedCount === stylesheets.length) {
                            resolve();
                        }
                    };

                    stylesheets.forEach(sheet => {
                        try {
                            // Â∞ùËØïËÆøÈóÆÊ†∑ÂºèË°®ËßÑÂàôÊù•Á°ÆËÆ§Âä†ËΩΩÂÆåÊàê
                            const rules = sheet.cssRules || sheet.rules;
                            checkComplete();
                        } catch (e) {
                            // Â¶ÇÊûúÊó†Ê≥ïËÆøÈóÆÔºåÂèØËÉΩËøòÂú®Âä†ËΩΩ‰∏≠
                            if (sheet.ownerNode) {
                                sheet.ownerNode.onload = checkComplete;
                                sheet.ownerNode.onerror = checkComplete;
                            } else {
                                checkComplete();
                            }
                        }
                    });

                    // Ë∂ÖÊó∂‰øùÊä§
                    setTimeout(resolve, 3000);
                });
            }"""
            )

            # Ê£ÄÊü•ÊòØÂê¶ÊúâÂª∂ËøüÂä†ËΩΩÁöÑÂÜÖÂÆπ
            await page.evaluate(
                """() => {
                // Ëß¶ÂèëÊâÄÊúâÂèØËÉΩÁöÑÊáíÂä†ËΩΩÂÜÖÂÆπ
                const lazyElements = document.querySelectorAll('[data-src], [loading="lazy"], .lazy');
                lazyElements.forEach(el => {
                    if (el.dataset.src) {
                        el.src = el.dataset.src;
                    }
                    // ÊªöÂä®Âà∞ÂÖÉÁ¥†‰ΩçÁΩÆËß¶ÂèëÊáíÂä†ËΩΩ
                    el.scrollIntoView();
                });

                // Âº∫Âà∂ÈáçÊñ∞ËÆ°ÁÆóÊâÄÊúâÂÖÉÁ¥†ÁöÑÊ†∑Âºè
                document.querySelectorAll('*').forEach(el => {
                    window.getComputedStyle(el).getPropertyValue('opacity');
                });
            }"""
            )

            elapsed_time = time.time() * 1000 - start_time
            logger.debug(f"‚úÖ Â≠ó‰ΩìÂíåËµÑÊ∫êÂä†ËΩΩÂÆåÊàêÔºåËÄóÊó∂: {elapsed_time:.0f}ms")

        except Exception as error:
            logger.debug(f"‚ö†Ô∏è Â≠ó‰ΩìÂíåËµÑÊ∫êÁ≠âÂæÖËøáÁ®ã‰∏≠Âá∫Èîô: {error}")

    async def _comprehensive_page_ready_check(self, page: Page) -> bool:
        """ÁªºÂêàÊ£ÄÊü•È°µÈù¢ÊòØÂê¶ÂÆåÂÖ®ÂáÜÂ§áÂ∞±Áª™"""
        logger.debug("üîç ÊâßË°åÁªºÂêàÈ°µÈù¢Â∞±Áª™Ê£ÄÊü•...")

        try:
            page_status = await page.evaluate(
                """() => {
                const status = {
                    domReady: document.readyState === 'complete',
                    fontsReady: false,
                    imagesLoaded: true,
                    scriptsLoaded: true,
                    stylesheetsLoaded: true,
                    chartsReady: true,
                    noActiveAnimations: true,
                    visibleContent: false,
                    errors: []
                };

                // Ê£ÄÊü•Â≠ó‰Ωì
                if (document.fonts && document.fonts.status) {
                    status.fontsReady = document.fonts.status === 'loaded';
                } else {
                    status.fontsReady = true; // ÂÅáËÆæÂ∑≤Âä†ËΩΩ
                }

                // Ê£ÄÊü•ÂõæÁâá
                document.querySelectorAll('img').forEach((img, index) => {
                    if (!img.complete || img.naturalWidth === 0) {
                        status.imagesLoaded = false;
                        status.errors.push(`Image ${index} not loaded`);
                    }
                });

                // Ê£ÄÊü•ËÑöÊú¨
                document.querySelectorAll('script[src]').forEach((script, index) => {
                    if (script.readyState && script.readyState !== 'complete' && script.readyState !== 'loaded') {
                        status.scriptsLoaded = false;
                        status.errors.push(`Script ${index} not loaded`);
                    }
                });

                // Ê£ÄÊü•Ê†∑ÂºèË°®
                try {
                    Array.from(document.styleSheets).forEach((sheet, index) => {
                        try {
                            const rules = sheet.cssRules || sheet.rules;
                            // Â¶ÇÊûúËÉΩËÆøÈóÆËßÑÂàôÔºåËØ¥ÊòéÂ∑≤Âä†ËΩΩ
                        } catch (e) {
                            status.stylesheetsLoaded = false;
                            status.errors.push(`Stylesheet ${index} not accessible`);
                        }
                    });
                } catch (e) {
                    status.errors.push(`Stylesheet check failed: ${e.message}`);
                }

                // Ê£ÄÊü•ÂõæË°®
                const canvasElements = document.querySelectorAll('canvas');
                const svgElements = document.querySelectorAll('svg');

                if (canvasElements.length > 0 || svgElements.length > 0) {
                    let renderedCount = 0;
                    let totalCount = canvasElements.length + svgElements.length;

                    // Ê£ÄÊü•canvas
                    canvasElements.forEach(canvas => {
                        try {
                            const ctx = canvas.getContext('2d');
                            if (ctx && canvas.width > 0 && canvas.height > 0) {
                                const imageData = ctx.getImageData(0, 0, Math.min(50, canvas.width), Math.min(50, canvas.height));
                                for (let i = 3; i < imageData.data.length; i += 4) {
                                    if (imageData.data[i] > 0) {
                                        renderedCount++;
                                        break;
                                    }
                                }
                            }
                        } catch (e) {
                            renderedCount++; // ‰øùÂÆàÂ§ÑÁêÜ
                        }
                    });

                    // Ê£ÄÊü•SVG
                    svgElements.forEach(svg => {
                        const graphicElements = svg.querySelectorAll('path, circle, rect, line, polygon, text');
                        if (graphicElements.length > 0) {
                            renderedCount++;
                        }
                    });

                    status.chartsReady = renderedCount >= totalCount * 0.8; // Ëá≥Â∞ë80%Ê∏≤Êüì
                }

                // Ê£ÄÊü•Âä®Áîª
                const animatedElements = document.querySelectorAll('[style*="animation"], [style*="transition"], .animate');
                status.noActiveAnimations = animatedElements.length === 0;

                // Ê£ÄÊü•ÂèØËßÅÂÜÖÂÆπ
                const contentElements = document.querySelectorAll('body *');
                for (let el of contentElements) {
                    const rect = el.getBoundingClientRect();
                    if (rect.width > 0 && rect.height > 0) {
                        status.visibleContent = true;
                        break;
                    }
                }

                return status;
            }"""
            )

            logger.debug(
                f"üìä È°µÈù¢Áä∂ÊÄÅ: DOM:{page_status['domReady']}, Â≠ó‰Ωì:{page_status['fontsReady']}, ÂõæÁâá:{page_status['imagesLoaded']}, ËÑöÊú¨:{page_status['scriptsLoaded']}, Ê†∑Âºè:{page_status['stylesheetsLoaded']}, ÂõæË°®:{page_status['chartsReady']}, Êó†Âä®Áîª:{page_status['noActiveAnimations']}, ÂèØËßÅÂÜÖÂÆπ:{page_status['visibleContent']}"
            )

            if page_status["errors"]:
                logger.debug(f"‚ö†Ô∏è Ê£ÄÊü•‰∏≠ÂèëÁé∞ÈóÆÈ¢ò: {page_status['errors'][:5]}")  # Âè™ÊòæÁ§∫Ââç5‰∏™ÈîôËØØ

            # Âà§Êñ≠È°µÈù¢ÊòØÂê¶ÂÆåÂÖ®Â∞±Áª™
            is_ready = (
                page_status["domReady"]
                and page_status["fontsReady"]
                and page_status["imagesLoaded"]
                and page_status["scriptsLoaded"]
                and page_status["stylesheetsLoaded"]
                and page_status["chartsReady"]
                and page_status["visibleContent"]
            )

            if is_ready:
                logger.debug("‚úÖ È°µÈù¢ÂÆåÂÖ®Â∞±Áª™")
            else:
                logger.debug("‚ö†Ô∏è È°µÈù¢Â∞öÊú™ÂÆåÂÖ®Â∞±Áª™Ôºå‰ΩÜÂ∞ÜÁªßÁª≠Â§ÑÁêÜ")

            return is_ready

        except Exception as error:
            logger.debug(f"‚ö†Ô∏è È°µÈù¢Â∞±Áª™Ê£ÄÊü•Â§±Ë¥•: {error}")
            return False

    async def _inject_pdf_styles(self, page: Page):
        """Inject CSS styles optimized for PDF generation"""
        pdf_styles = """
            /* Comprehensive animation and transition disabling for PDF */
            *, *::before, *::after {
                animation-duration: 0s !important;
                animation-delay: 0s !important;
                animation-iteration-count: 1 !important;
                animation-play-state: paused !important;
                transition-property: none !important;
                transition-duration: 0s !important;
                transition-delay: 0s !important;
                transform-origin: center center !important;
            }

            /* Disable CSS animations globally */
            @keyframes * {
                0%, 100% {
                    animation-play-state: paused !important;
                }
            }

            /* Ensure transforms are reset */
            .slide-container {
                transform: rotateY(0deg) rotateX(0deg) !important;
            }

            /* Ensure all elements are visible and properly positioned */
            .feature-card, .slide-content, .content-section {
                opacity: 1 !important;
                transform: translateY(0) translateX(0) scale(1) !important;
                visibility: visible !important;
            }

            /* Ensure charts and canvas elements are visible and properly sized */
            canvas, .chart-container, [id*="chart"], [class*="chart"] {
                opacity: 1 !important;
                visibility: visible !important;
                display: block !important;
                position: relative !important;
                transform: none !important;
                animation: none !important;
                transition: none !important;
            }

            /* Force chart containers to maintain their dimensions */
            .chart-container {
                min-height: 300px !important;
                width: 100% !important;
            }

            /* Force 1280x720 landscape layout */
            html, body {
                width: 1280px !important;
                height: 720px !important;
                margin: 0 !important;
                padding: 0 !important;
                overflow: hidden !important;
                box-sizing: border-box !important;
            }

            /* Ensure proper page breaks for slides */
            .slide-page {
                page-break-before: always !important;
                page-break-after: always !important;
                page-break-inside: avoid !important;
                break-before: always !important;
                break-after: always !important;
                break-inside: avoid !important;
                display: block !important;
                width: 1280px !important;
                height: 720px !important;
                margin: 0 !important;
                padding: 0 !important;
                box-sizing: border-box !important;
            }

            .slide-page:first-child {
                page-break-before: avoid !important;
                break-before: avoid !important;
            }

            .slide-page:last-child {
                page-break-after: avoid !important;
                break-after: avoid !important;
            }

            /* Optimize for print */
            body {
                -webkit-print-color-adjust: exact !important;
                color-adjust: exact !important;
                margin: 0 !important;
                padding: 0 !important;
            }

            @media print {
                @page {
                    size: 338.67mm 190.5mm !important;
                    margin: 0 !important;
                }

                html, body {
                    width: 1280px !important;
                    height: 720px !important;
                }

                * {
                    -webkit-print-color-adjust: exact !important;
                    color-adjust: exact !important;
                }
            }
        """

        await page.add_style_tag(content=pdf_styles)

    async def _inject_javascript_optimizations(self, page: Page):
        """Enhanced JavaScript optimizations for Chart.js, ECharts, and D3.js"""
        # Pre-load optimizations
        await page.add_init_script(
            """() => {
            // Override animation-related functions globally
            window.requestAnimationFrame = function(callback) {
                return setTimeout(callback, 0);
            };

            window.cancelAnimationFrame = function(id) {
                clearTimeout(id);
            };

            // Disable jQuery animations if present
            if (window.jQuery) {
                window.jQuery.fx.off = true;
            }

            // Override Chart.js defaults before any charts are created
            if (typeof Chart !== 'undefined') {
                Chart.defaults.animation = false;
                Chart.defaults.responsive = true;
                Chart.defaults.maintainAspectRatio = false;
            }

            // Override ECharts animation settings
            if (typeof echarts !== 'undefined') {
                const originalInit = echarts.init;
                echarts.init = function(dom, theme, opts) {
                    const chart = originalInit.call(this, dom, theme, opts);
                    // Disable animations for all ECharts instances
                    const originalSetOption = chart.setOption;
                    chart.setOption = function(option, notMerge, lazyUpdate) {
                        if (option && typeof option === 'object') {
                            option.animation = false;
                            option.animationDuration = 0;
                            option.animationEasing = 'linear';
                            if (option.series) {
                                if (Array.isArray(option.series)) {
                                    option.series.forEach(s => {
                                        s.animation = false;
                                        s.animationDuration = 0;
                                    });
                                } else {
                                    option.series.animation = false;
                                    option.series.animationDuration = 0;
                                }
                            }
                            // Á¶ÅÁî®ÂêÑÁßçÂä®ÁîªÊïàÊûú
                            if (option.animationDurationUpdate) option.animationDurationUpdate = 0;
                            if (option.animationDelayUpdate) option.animationDelayUpdate = 0;
                        }
                        return originalSetOption.call(this, option, notMerge, lazyUpdate);
                    };
                    return chart;
                };
            }

            // Override D3.js transition settings
            if (typeof d3 !== 'undefined') {
                // Override transition creation
                const originalTransition = d3.transition;
                d3.transition = function() {
                    const t = originalTransition.apply(this, arguments);
                    if (t && typeof t.duration === 'function') {
                        return t.duration(0);
                    }
                    return t;
                };

                // Override selection.transition
                if (d3.selection && d3.selection.prototype.transition) {
                    const originalSelectionTransition = d3.selection.prototype.transition;
                    d3.selection.prototype.transition = function() {
                        const t = originalSelectionTransition.apply(this, arguments);
                        if (t && typeof t.duration === 'function') {
                            return t.duration(0);
                        }
                        return t;
                    };
                }
            }
        }"""
        )

        # Post-load optimizations
        await page.evaluate(
            """() => {
            // Enhanced Chart.js animation disabling
            if (window.Chart) {
                // Set global Chart.js defaults
                if (window.Chart.defaults) {
                    if (window.Chart.defaults.global) {
                        window.Chart.defaults.global.animation = false;
                        window.Chart.defaults.global.responsive = true;
                        window.Chart.defaults.global.maintainAspectRatio = false;
                    }
                    if (window.Chart.defaults.animation) {
                        window.Chart.defaults.animation.duration = 0;
                        window.Chart.defaults.animation.animateRotate = false;
                        window.Chart.defaults.animation.animateScale = false;
                    }
                    if (window.Chart.defaults.plugins && window.Chart.defaults.plugins.legend) {
                        window.Chart.defaults.plugins.legend.animation = false;
                    }
                }

                // Disable animations for existing instances
                if (window.Chart.instances) {
                    Object.values(window.Chart.instances).forEach(chart => {
                        if (chart && chart.options) {
                            chart.options.animation = false;
                            if (chart.options.plugins && chart.options.plugins.legend) {
                                chart.options.plugins.legend.animation = false;
                            }
                        }
                    });
                }
            }

            // Enhanced ECharts animation disabling for existing instances
            if (window.echarts) {
                document.querySelectorAll('[_echarts_instance_], [id*="chart"], [class*="chart"], [class*="echarts"]').forEach(el => {
                    const instance = window.echarts.getInstanceByDom(el);
                    if (instance) {
                        try {
                            const option = instance.getOption();
                            if (option) {
                                // Ê∑±Â∫¶Á¶ÅÁî®ÊâÄÊúâÂä®Áîª
                                const newOption = JSON.parse(JSON.stringify(option));
                                newOption.animation = false;
                                newOption.animationDuration = 0;
                                newOption.animationEasing = 'linear';
                                newOption.animationDurationUpdate = 0;
                                newOption.animationDelayUpdate = 0;

                                if (newOption.series) {
                                    if (Array.isArray(newOption.series)) {
                                        newOption.series.forEach(s => {
                                            s.animation = false;
                                            s.animationDuration = 0;
                                            s.animationDelay = 0;
                                        });
                                    } else {
                                        newOption.series.animation = false;
                                        newOption.series.animationDuration = 0;
                                        newOption.series.animationDelay = 0;
                                    }
                                }

                                // Á¶ÅÁî®ÂêÑ‰∏™ÁªÑ‰ª∂ÁöÑÂä®Áîª
                                ['xAxis', 'yAxis', 'legend', 'tooltip', 'dataZoom'].forEach(component => {
                                    if (newOption[component]) {
                                        if (Array.isArray(newOption[component])) {
                                            newOption[component].forEach(c => c.animation = false);
                                        } else {
                                            newOption[component].animation = false;
                                        }
                                    }
                                });

                                instance.setOption(newOption, true);
                            }
                        } catch (e) {
                            console.warn('EChartsÂä®ÁîªÁ¶ÅÁî®Â§±Ë¥•:', e.message);
                        }
                    }
                });
            }

            // Enhanced D3.js transition disabling
            if (window.d3) {
                // Override existing transition methods
                if (d3.transition) {
                    const originalTransition = d3.transition;
                    d3.transition = function() {
                        const t = originalTransition.apply(this, arguments);
                        if (t && typeof t.duration === 'function') {
                            return t.duration(0);
                        }
                        return t;
                    };
                }

                // Override selection.transition for existing selections
                if (d3.selection && d3.selection.prototype.transition) {
                    const originalSelectionTransition = d3.selection.prototype.transition;
                    d3.selection.prototype.transition = function() {
                        const t = originalSelectionTransition.apply(this, arguments);
                        if (t && typeof t.duration === 'function') {
                            return t.duration(0);
                        }
                        return t;
                    };
                }

                // ‰∏≠Êñ≠ÊâÄÊúâÊ≠£Âú®ËøõË°åÁöÑD3 transition
                try {
                    d3.selectAll('*').interrupt();
                } catch (e) {
                    console.warn('D3 transition‰∏≠Êñ≠Â§±Ë¥•:', e.message);
                }
            }

            // Override setTimeout and setInterval for faster execution
            const originalSetTimeout = window.setTimeout;
            const originalSetInterval = window.setInterval;

            window.setTimeout = function(callback, delay) {
                return originalSetTimeout(callback, Math.min(delay || 0, 10));
            };

            window.setInterval = function(callback, delay) {
                return originalSetInterval(callback, Math.min(delay || 0, 10));
            };

            // Force immediate execution of any pending animations
            if (window.getComputedStyle) {
                document.querySelectorAll('*').forEach(el => {
                    try {
                        window.getComputedStyle(el).getPropertyValue('transform');
                    } catch (e) {
                        // Ignore errors
                    }
                });
            }

            // Âº∫Âà∂ÂÆåÊàêÊâÄÊúâÂèØËÉΩÁöÑÂºÇÊ≠•Ê∏≤Êüì
            if (window.requestIdleCallback) {
                window.requestIdleCallback = function(callback) {
                    return setTimeout(callback, 0);
                };
            }
        }"""
        )

    async def html_to_pdf(
        self,
        html_file_path: str,
        pdf_output_path: str,
        options: Optional[Dict[str, Any]] = None,
    ) -> bool:
        """
        Convert HTML file to PDF using Pyppeteer
        Optimized for 16:9 PPT slides with complete style preservation
        """
        logger.info(f"üöÄ Starting PDF conversion for: {html_file_path}")

        if not os.path.exists(html_file_path):
            logger.error(f"‚ùå Error: HTML file not found at {html_file_path}")
            return False

        if options is None:
            options = {}

        page = None
        try:
            # Get or create shared browser
            browser = await self._get_or_create_browser()
            page = await self.context.new_page()

            # Set viewport for 16:9 aspect ratio (1280x720)
            viewport_width = options.get("viewportWidth", 1280)
            viewport_height = options.get("viewportHeight", 720)
            await page.set_viewport_size({"width": viewport_width, "height": viewport_height})

            # Navigate to the HTML file
            absolute_html_path = Path(html_file_path).resolve()
            logger.debug(f"üìÑ Navigating to: file://{absolute_html_path}")

            await page.goto(
                f"file://{absolute_html_path}",
                wait_until="networkidle",  # Á≠âÂæÖÁΩëÁªúÁ©∫Èó≤ÔºåÁ°Æ‰øùÊâÄÊúâËµÑÊ∫êÂä†ËΩΩÂÆåÊàê
                timeout=60000,
            )  # Â¢ûÂä†Ë∂ÖÊó∂Êó∂Èó¥‰ª•Á°Æ‰øùÂÆåÊï¥Âä†ËΩΩ

            # Êô∫ËÉΩÁ≠âÂæÖÔºöÊ†πÊçÆÈ°µÈù¢Â§çÊùÇÂ∫¶Âä®ÊÄÅË∞ÉÊï¥Á≠âÂæÖÊó∂Èó¥
            page_complexity = await page.evaluate(
                """() => {
                const complexity = {
                    canvasCount: document.querySelectorAll('canvas').length,
                    svgCount: document.querySelectorAll('svg').length,
                    imageCount: document.querySelectorAll('img').length,
                    scriptCount: document.querySelectorAll('script').length,
                    stylesheetCount: document.styleSheets.length,
                    totalElements: document.querySelectorAll('*').length
                };

                // ËÆ°ÁÆóÂ§çÊùÇÂ∫¶ÂàÜÊï∞
                let score = 0;
                score += complexity.canvasCount * 3;  // ÂõæË°®ÊùÉÈáçÈ´ò
                score += complexity.svgCount * 2;
                score += complexity.imageCount * 1;
                score += complexity.scriptCount * 1;
                score += complexity.stylesheetCount * 1;
                score += Math.floor(complexity.totalElements / 100);

                return {
                    ...complexity,
                    complexityScore: score
                };
            }"""
            )

            # Ê†πÊçÆÂ§çÊùÇÂ∫¶Ë∞ÉÊï¥Á≠âÂæÖÊó∂Èó¥
            base_wait = 1.0
            if page_complexity["complexityScore"] > 20:
                wait_time = base_wait + 1.5  # Â§çÊùÇÈ°µÈù¢Á≠âÂæÖÊõ¥‰πÖ
            elif page_complexity["complexityScore"] > 10:
                wait_time = base_wait + 1.0
            elif page_complexity["complexityScore"] > 5:
                wait_time = base_wait + 0.5
            else:
                wait_time = base_wait

            logger.debug(
                f"üìä È°µÈù¢Â§çÊùÇÂ∫¶ÂàÜÊûê: ÂõæË°®:{page_complexity['canvasCount']+page_complexity['svgCount']}, ÂõæÁâá:{page_complexity['imageCount']}, ÊÄªÂàÜ:{page_complexity['complexityScore']}, Á≠âÂæÖÊó∂Èó¥:{wait_time}s"
            )
            await asyncio.sleep(wait_time)

            # Á≠âÂæÖÂ≠ó‰ΩìÂíåÂ§ñÈÉ®ËµÑÊ∫êÂä†ËΩΩÂÆåÊàê
            await self._wait_for_fonts_and_resources(page)

            # Inject optimizations
            await self._inject_pdf_styles(page)
            await self._inject_javascript_optimizations(page)

            # Force chart initialization after page load
            await self._force_chart_initialization(page)

            # Enhanced waiting for Chart.js and dynamic content rendering
            await self._wait_for_charts_and_dynamic_content(page)

            # Perform final chart verification before PDF generation
            await self._perform_final_chart_verification(page)

            # ÊúÄÁªàÁ°ÆËÆ§ÊâÄÊúâÂÜÖÂÆπÂ∑≤ÂáÜÂ§áÂ∞±Áª™
            logger.debug("üîç ÊâßË°åÊúÄÁªàÂÜÖÂÆπÊ£ÄÊü•...")
            await page.evaluate(
                """() => {
                // ÊúÄÂêé‰∏ÄÊ¨°Âº∫Âà∂ÈáçÊéíÂíåÈáçÁªò
                document.body.offsetHeight;

                // Á°Æ‰øùÊâÄÊúâÂõæË°®ÂÆπÂô®ÈÉΩÂèØËßÅ
                document.querySelectorAll('canvas, svg, [id*="chart"], [class*="chart"]').forEach(el => {
                    if (el.style.display === 'none') {
                        el.style.display = 'block';
                    }
                    if (el.style.visibility === 'hidden') {
                        el.style.visibility = 'visible';
                    }
                });

                return new Promise(resolve => {
                    requestAnimationFrame(() => {
                        requestAnimationFrame(resolve);
                    });
                });
            }"""
            )

            # ÊúÄÁªàÁ®≥ÂÆöÁ≠âÂæÖ
            await asyncio.sleep(0.5)

            # ÊâßË°åÊúÄÁªàÁöÑÁªºÂêàÈ°µÈù¢Â∞±Áª™Ê£ÄÊü•
            await self._comprehensive_page_ready_check(page)

            # PDF generation options - optimized for 1280x720 landscape (16:9)
            pdf_options = {
                "path": pdf_output_path,
                "width": "338.67mm",  # 1280px at 96dpi = 338.67mm (landscape width)
                "height": "190.5mm",  # 720px at 96dpi = 190.5mm (landscape height)
                "print_background": True,  # Include background colors and images
                "landscape": False,  # Set to false since we're manually setting dimensions
                "margin": {
                    "top": "0mm",
                    "right": "0mm",
                    "bottom": "0mm",
                    "left": "0mm",
                },
                "prefer_css_page_size": False,  # Use our custom dimensions
                "display_header_footer": False,  # No header/footer
                "scale": 1,  # No scaling
            }

            logger.debug(
                f"üìë Generating PDF with options: {pdf_options['width']} x {pdf_options['height']}"
            )

            await page.pdf(**pdf_options)

            logger.info(f"‚úÖ PDF generated successfully: {pdf_output_path}")
            return True

        except Exception as error:
            logger.error(f"‚ùå Error during PDF generation: {error}")
            return False
        finally:
            if page:
                await page.close()
                logger.debug("üìÑ Page closed.")

    async def html_to_pdf_with_browser(
        self,
        browser: Browser,
        html_file_path: str,
        pdf_output_path: str,
        options: Optional[Dict[str, Any]] = None,
    ) -> bool:
        """
        Convert HTML file to PDF using an existing browser instance
        More efficient for batch processing
        """
        logger.info(f"üöÄ Converting with shared browser: {html_file_path}")

        if not os.path.exists(html_file_path):
            logger.error(f"‚ùå Error: HTML file not found at {html_file_path}")
            return False

        if options is None:
            options = {}

        page = None
        try:
            # Create a new context for this conversion to ensure isolation
            context = await browser.new_context(
                viewport={
                    "width": options.get("viewportWidth", 1280),
                    "height": options.get("viewportHeight", 720),
                },
                device_scale_factor=2,
                ignore_https_errors=True,
            )
            page = await context.new_page()

            # Navigate to the HTML file with comprehensive loading strategy
            absolute_html_path = Path(html_file_path).resolve()
            await page.goto(
                f"file://{absolute_html_path}",
                wait_until="networkidle",  # Á≠âÂæÖÁΩëÁªúÁ©∫Èó≤ÔºåÁ°Æ‰øùÊâÄÊúâËµÑÊ∫êÂä†ËΩΩÂÆåÊàê
                timeout=60000,
            )  # ÈÄÇÂΩìÁöÑË∂ÖÊó∂Êó∂Èó¥

            # ÊâπÂ§ÑÁêÜ‰∏≠‰πüÈúÄË¶ÅÈ¢ùÂ§ñÁ≠âÂæÖÁ°Æ‰øùÂÜÖÂÆπÂÆåÂÖ®Âä†ËΩΩ
            await asyncio.sleep(0.8)

            # Á≠âÂæÖÂ≠ó‰ΩìÂíåÂ§ñÈÉ®ËµÑÊ∫êÂä†ËΩΩÂÆåÊàêÔºàÊâπÂ§ÑÁêÜÁâàÊú¨ÔºåÊó∂Èó¥Á®çÁü≠Ôºâ
            await self._wait_for_fonts_and_resources(page, max_wait_time=50000)

            # Force chart initialization after page load
            await self._force_chart_initialization(page)

            # Enhanced waiting for Chart.js and dynamic content rendering
            await self._wait_for_charts_and_dynamic_content(page, max_wait_time=120000)

            # Enhanced CSS injection for batch processing
            await page.add_style_tag(
                content="""
                    /* Comprehensive animation and transition disabling for PDF */
                    *, *::before, *::after {
                        animation-duration: 0s !important;
                        animation-delay: 0s !important;
                        animation-iteration-count: 1 !important;
                        animation-play-state: paused !important;
                        transition-property: none !important;
                        transition-duration: 0s !important;
                        transition-delay: 0s !important;
                        transform-origin: center center !important;
                    }

                    /* Disable CSS animations globally */
                    @keyframes * {
                        0%, 100% {
                            animation-play-state: paused !important;
                        }
                    }

                    /* Ensure charts and canvas elements are visible */
                    canvas, .chart-container, [id*="chart"], [class*="chart"] {
                        opacity: 1 !important;
                        visibility: visible !important;
                        display: block !important;
                        position: relative !important;
                        transform: none !important;
                        animation: none !important;
                        transition: none !important;
                    }

                    @media print {
                        * {
                            -webkit-print-color-adjust: exact !important;
                            print-color-adjust: exact !important;
                        }
                    }
                """
            )

            # Inject JavaScript optimizations for batch processing
            await page.evaluate(
                """() => {
                // Force disable Chart.js animations
                if (window.Chart && window.Chart.defaults) {
                    if (window.Chart.defaults.global) {
                        window.Chart.defaults.global.animation = false;
                    }
                    if (window.Chart.defaults.animation) {
                        window.Chart.defaults.animation.duration = 0;
                    }
                }
            }"""
            )

            # Perform final chart verification before PDF generation
            await self._perform_final_chart_verification(page)

            # ÊâπÂ§ÑÁêÜ‰∏≠ÁöÑÊúÄÁªàÈ°µÈù¢Â∞±Áª™Ê£ÄÊü•
            await self._comprehensive_page_ready_check(page)

            # PDF generation options - 1280x720 landscape (16:9)
            pdf_options = {
                "path": pdf_output_path,
                "width": "338.67mm",  # 1280px at 96dpi = 338.67mm (landscape width)
                "height": "190.5mm",  # 720px at 96dpi = 190.5mm (landscape height)
                "print_background": True,
                "landscape": False,  # Set to false since we're manually setting dimensions
                "margin": {
                    "top": "0mm",
                    "right": "0mm",
                    "bottom": "0mm",
                    "left": "0mm",
                },
                "prefer_css_page_size": False,  # Use our custom dimensions
                "display_header_footer": False,
                "scale": 1,
            }

            await page.pdf(**pdf_options)
            logger.info(f"‚úÖ PDF generated: {pdf_output_path}")
            return True

        except Exception as error:
            logger.error(f"‚ùå Error converting {html_file_path}: {error}")
            return False
        finally:
            if page:
                await page.close()
            if "context" in locals():
                await context.close()

    async def convert_multiple_html_to_pdf(
        self,
        html_files: List[str],
        output_dir: str,
        merged_pdf_path: Optional[str] = None,
    ) -> List[str]:
        """
        Convert multiple HTML files to PDFs and optionally merge them
        Optimized version with shared browser instance and parallel processing
        """
        logger.info(f"üöÄ Starting batch PDF conversion for {len(html_files)} files")

        pdf_files = []
        browser = None

        try:
            # Launch browser once for all conversions with enhanced chart rendering support
            browser = await self._launch_browser()

            # Process files in smaller batches to avoid memory issues
            # Adjust batch size based on total number of files
            batch_size = 3 if len(html_files) > 20 else 4 if len(html_files) > 10 else 5

            for i in range(0, len(html_files), batch_size):
                batch = html_files[i : i + batch_size]
                batch_num = i // batch_size + 1
                total_batches = (len(html_files) + batch_size - 1) // batch_size
                logger.info(f"üì¶ Processing batch {batch_num}/{total_batches} ({len(batch)} files)")

                # Process batch with retry mechanism
                batch_results = []
                for batch_index, html_file in enumerate(batch):
                    global_index = i + batch_index
                    base_name = Path(html_file).stem
                    pdf_file = os.path.join(output_dir, f"{base_name}.pdf")

                    logger.info(f"üìÑ Converting {global_index + 1}/{len(html_files)}: {html_file}")

                    # Try conversion with retry mechanism
                    success = False
                    retry_count = 0
                    max_retries = 5

                    while not success and retry_count <= max_retries:
                        if retry_count > 0:
                            logger.info(f"üîÑ Retry {retry_count}/{max_retries} for: {html_file}")
                            # Wait a bit before retry
                            await asyncio.sleep(2)

                        success = await self.html_to_pdf_with_browser(browser, html_file, pdf_file)
                        retry_count += 1

                    if success:
                        batch_results.append(pdf_file)
                    else:
                        logger.error(
                            f"‚ùå Failed to convert after {max_retries} retries: {html_file}"
                        )

                pdf_files.extend(batch_results)

                # Small delay between batches to prevent overwhelming the system
                if i + batch_size < len(html_files):
                    logger.info("üíæ Memory cleanup between batches...")
                    await asyncio.sleep(2)

            logger.info(f"‚úÖ Batch conversion completed. Generated {len(pdf_files)} PDF files.")

            # If merging is requested and we have PDFs
            if merged_pdf_path and len(pdf_files) > 0:
                if len(pdf_files) == 1:
                    # For single PDF, just copy it to the merged path
                    logger.info("üìÑ Single PDF detected, copying to merged path...")
                    try:
                        import shutil

                        from ..utils.thread_pool import run_blocking_io

                        await run_blocking_io(shutil.copy2, pdf_files[0], merged_pdf_path)
                        logger.info(f"‚úÖ Single PDF copied to: {merged_pdf_path}")
                    except Exception as e:
                        logger.error(f"‚ùå Failed to copy single PDF: {e}")
                        return pdf_files
                else:
                    # For multiple PDFs, merge them
                    logger.info("üîó Merging multiple PDFs...")
                    merge_success = await self.merge_pdfs(pdf_files, merged_pdf_path)
                    if merge_success:
                        logger.info(f"‚úÖ Merged PDF created: {merged_pdf_path}")

            return pdf_files

        except Exception as error:
            logger.error(f"‚ùå Error during batch PDF conversion: {error}")
            return []
        finally:
            if browser:
                await browser.close()
                logger.debug("üîí Shared browser closed.")

    def _merge_pdfs_sync(self, pdf_files: List[str], output_path: str) -> bool:
        """Synchronous PDF merging function to be run in thread pool"""
        try:
            # Try to use PyPDF2 first
            try:
                from PyPDF2 import PdfMerger

                merger = PdfMerger()

                for pdf_file in pdf_files:
                    if os.path.exists(pdf_file):
                        merger.append(pdf_file)

                with open(output_path, "wb") as output_file:
                    merger.write(output_file)

                merger.close()
                return True

            except ImportError:
                # Fallback to pypdf
                from pypdf import PdfMerger

                merger = PdfMerger()

                for pdf_file in pdf_files:
                    if os.path.exists(pdf_file):
                        merger.append(pdf_file)

                with open(output_path, "wb") as output_file:
                    merger.write(output_file)

                merger.close()
                return True

        except Exception as error:
            logger.error(f"‚ùå Error merging PDFs: {error}")
            logger.info("üí° Tip: Install PyPDF2 for PDF merging: pip install PyPDF2")
            return False

    async def merge_pdfs(self, pdf_files: List[str], output_path: str) -> bool:
        """Merge multiple PDF files into one using thread pool to avoid blocking"""
        from ..utils.thread_pool import run_blocking_io

        return await run_blocking_io(self._merge_pdfs_sync, pdf_files, output_path)

    async def close(self):
        """Close the browser if it's still open"""
        async with self._browser_lock:
            if self.context:
                await self.context.close()
                self.context = None
            if self.browser:
                await self.browser.close()
                self.browser = None
            if self.playwright:
                await self.playwright.stop()
                self.playwright = None
                logger.debug("üîí Shared browser and Playwright closed.")


# Global converter instance
_pdf_converter = None


def get_pdf_converter() -> PlaywrightPDFConverter:
    """Get the global PDF converter instance"""
    global _pdf_converter
    if _pdf_converter is None:
        _pdf_converter = PlaywrightPDFConverter()
    return _pdf_converter


async def convert_html_to_pdf(
    html_file_path: str, pdf_output_path: str, options: Optional[Dict[str, Any]] = None
) -> bool:
    """Convenience function for single HTML to PDF conversion"""
    converter = get_pdf_converter()
    return await converter.html_to_pdf(html_file_path, pdf_output_path, options)


async def convert_multiple_html_to_pdf(
    html_files: List[str], output_dir: str, merged_pdf_path: Optional[str] = None
) -> List[str]:
    """Convenience function for batch HTML to PDF conversion"""
    converter = get_pdf_converter()
    return await converter.convert_multiple_html_to_pdf(html_files, output_dir, merged_pdf_path)
