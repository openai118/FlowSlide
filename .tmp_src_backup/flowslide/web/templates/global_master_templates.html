{% extends "base.html" %}

{% block title %}å…¨å±€æ¯ç‰ˆç®¡ç†{% endblock %}

{% block extra_css %}
<style>
/* ç°ä»£åŒ–å…¨å±€æ¯ç‰ˆç®¡ç†é¡µé¢ - ä¼˜åŒ–å¸ƒå±€ */
    .template-actions {
    padding: 12px 14px;
    border-top: 1px solid var(--glass-border);
    background: var(--glass-bg);
    display: flex;
    gap: 8px;
    justify-content: center; /* center action buttons under the card */
    align-items: center;
    /* Allow buttons to wrap to the next line instead of overflowing the card */
    flex-wrap: wrap;
    box-sizing: border-box;
    overflow: visible;
}

    /* Keep button text readable, allow buttons to wrap as needed and shrink moderately */
    .template-actions .btn {
        white-space: nowrap;
        flex: 0 1 auto; /* allow wrapping and moderate shrinking to fit the card */
        margin: 4px 2px; /* small spacing when wrapped */
        min-width: 64px;
    }
    

@keyframes templatesFloat {
    0%, 100% { transform: scale(1) rotate(0deg); }
    50% { transform: scale(1.02) rotate(1deg); }
}

.templates-hero h1 {
    font-size: 1.8rem;
    font-weight: 700;
    margin-bottom: var(--spacing-sm);
    background: var(--primary-gradient);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    position: relative;
    z-index: 1;
    letter-spacing: -0.02em;
}

.templates-hero {
    animation: templatesFloat 20s ease-in-out infinite;
}

.templates-hero p {
    font-size: 1.1rem;
    color: var(--text-secondary);
    margin: 0;
    position: relative;
    z-index: 1;
    font-weight: 500;
}

.templates-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--spacing-lg);
    background: var(--glass-bg);
    backdrop-filter: blur(20px);
    border: 1px solid var(--glass-border);
    border-radius: var(--border-radius-md);
    padding: var(--spacing-lg);
    box-shadow: var(--glass-shadow);
}

.templates-actions {
    display: flex;
    gap: var(--spacing-sm);
    flex-wrap: wrap;
    align-items: center;
}

/* ç°ä»£åŒ–è¾“å…¥æ¡†å’Œè¡¨å•æ ·å¼ - ç™½è‰²èƒŒæ™¯ä¼˜åŒ– */
.glass-input, input[type="text"], input[type="email"], input[type="password"],
textarea, select {
    background: var(--glass-bg);
    border: 1px solid var(--glass-border);
    border-radius: var(--border-radius-sm);
    padding: 10px 14px;
    font-size: 0.9rem;
    color: var(--text-primary);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: var(--glass-shadow);
    outline: none;
    width: 100%;
    box-sizing: border-box;
}

.glass-input:focus, input[type="text"]:focus, input[type="email"]:focus,
input[type="password"]:focus, textarea:focus, select:focus {
    border-color: #667eea;
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    background: var(--glass-bg);
}

.glass-input::placeholder, input::placeholder, textarea::placeholder {
    color: var(--text-muted);
    font-weight: 400;
}

/* è¡¨å•æ ‡ç­¾æ ·å¼ */
.modal {
    position: fixed;
    inset: 0;
    z-index: 1000;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
    backdrop-filter: blur(8px);
    display: grid;
    place-items: center;
    animation: modalFadeIn 0.25s ease-out;
    padding: 20px;
    box-sizing: border-box;
    overflow: auto;
}
/* è¡¨å•ç»„æ ·å¼ - ä¼˜åŒ–é—´è· */
.form-group {
    margin-bottom: 16px;
}

.form-group label {
    margin-bottom: 6px;
    font-weight: 600;
    color: var(--text-primary);
    font-size: 0.9rem;
}

/* é€‰æ‹©æ¡†ç‰¹æ®Šæ ·å¼ */
select {
    cursor: pointer;
    background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
    background-position: right 12px center;
    background-repeat: no-repeat;
    background-size: 16px;
    padding-right: 40px;
    appearance: none;
}

/* æœç´¢å’Œè¿‡æ»¤åŒºåŸŸæ ·å¼ - ä¼˜åŒ–ç´§å‡‘å¸ƒå±€ */
.search-filter-container {
    display: flex;
    gap: var(--spacing-sm);
    margin-bottom: var(--spacing-md);
    padding: var(--spacing-md);
    background: var(--glass-bg);
    backdrop-filter: blur(20px);
    border: 1px solid var(--glass-border);
    border-radius: var(--border-radius-md);
    box-shadow: var(--glass-shadow);
    align-items: center;
    flex-wrap: wrap;
}

.search-input-wrapper {
    flex: 1;
    min-width: 220px;
    position: relative;
}

.search-input {
    padding: 10px 14px;
    transition: all 0.3s ease;
}

.search-input:focus {
    padding: 10px 14px;
}

.filter-wrapper {
    min-width: 160px;
}

.filter-select {
    min-width: 100%;
    padding: 10px 14px;
}

.refresh-btn {
    white-space: nowrap;
    min-width: auto;
    padding: 10px 16px;
}
</style>
{% endblock %}

{% block content %}
<div class="global-master-page">
<div class="templates-hero">
    <h1>ğŸ¨ å…¨å±€æ¯ç‰ˆç®¡ç†</h1>
    <p>ç®¡ç†å’Œåˆ›å»ºPPTå…¨å±€æ¯ç‰ˆæ¨¡æ¿</p>
</div>

<div style="max-width: 1400px; margin: 0 auto; padding: var(--spacing-md);">
    <!-- Header Actions -->
    <div class="templates-header">
        <div>
            <div style="display: flex; align-items: center; gap: 12px;">
                <h2 style="color: var(--text-primary); margin: 0; font-size: 1.3rem; font-weight: 600;">æ¨¡æ¿ç®¡ç†</h2>
                <a href="https://flowslide-template.52yyds.top" target="_blank" style="color: #667eea; text-decoration: none; font-size: 0.9rem; font-weight: 500; transition: color 0.3s ease;">æ¨¡æ¿å¸‚åœº</a>
            </div>
            <p style="color: var(--text-secondary); margin: 4px 0 0 0; font-size: 0.95rem;">åˆ›å»ºã€ç¼–è¾‘å’Œç®¡ç†æ‚¨çš„PPTæ¯ç‰ˆæ¨¡æ¿</p>
        </div>
        <div class="templates-actions">
            <button id="createTemplateBtn" class="btn btn-primary">
                â• æ–°å»ºæ¯ç‰ˆ
            </button>
            <button id="generateWithAIBtn" class="btn btn-success">
                ğŸ¤– AIç”Ÿæˆæ¯ç‰ˆ
            </button>
            <input type="file" id="importTemplateInput" accept=".html,.json" style="display: none;">
            <button id="importTemplateBtn" class="btn btn-secondary" onclick="document.getElementById('importTemplateInput').click()">
                ğŸ“¥ å¯¼å…¥æ¯ç‰ˆ
            </button>
        </div>
    </div>

    <!-- Filter and Search -->
    <div class="search-filter-container">
        <div class="search-input-wrapper">
            <input type="text" id="searchInput" placeholder="æœç´¢æ¯ç‰ˆåç§°..." class="glass-input search-input">
        </div>
        <div class="filter-wrapper">
            <select id="tagFilter" class="glass-input filter-select">
                <option value="">æ‰€æœ‰æ ‡ç­¾</option>
            </select>
        </div>
        <button id="refreshBtn" class="btn btn-info refresh-btn"><i class="fas fa-sync-alt"></i> åˆ·æ–°</button>
    </div>

    <!-- Templates Grid -->
    <div id="templatesGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(380px, 1fr)); gap: var(--spacing-lg);">
        <!-- Templates will be loaded here -->
    </div>

    <!-- Pagination -->
    <div id="paginationContainer" style="margin-top: var(--spacing-lg);">
        <div class="pagination-wrapper">
            <div class="pagination-info">
                <span id="paginationInfo">æ˜¾ç¤ºç¬¬ 1-12 é¡¹ï¼Œå…± 0 é¡¹</span>
            </div>
            <div class="pagination-controls">
                <button id="prevPageBtn" class="btn btn-sm btn-secondary" disabled>
                    <i class="fas fa-chevron-left"></i> ä¸Šä¸€é¡µ
                </button>
                <div id="pageNumbers" class="page-numbers">
                    <!-- Page numbers will be generated here -->
                </div>
                <button id="nextPageBtn" class="btn btn-sm btn-secondary" disabled>
                    ä¸‹ä¸€é¡µ <i class="fas fa-chevron-right"></i>
                </button>
            </div>
            <div class="pagination-size">
                <label for="pageSizeSelect">æ¯é¡µæ˜¾ç¤ºï¼š</label>
                <select id="pageSizeSelect" class="glass-input" style="width: auto; min-width: 80px;">
                    <option value="6" selected>6</option>
                    <option value="12">12</option>
                    <option value="24">24</option>
                    <option value="48">48</option>
                </select>
            </div>
        </div>
    </div>

    <!-- Loading indicator -->
    <div id="loadingIndicator" class="loading-container" style="display: none;">
        <div class="loading-spinner"></div>
        <p class="loading-text">åŠ è½½ä¸­...</p>
    </div>
</div>

<!-- Create/Edit Template Modal -->
<div id="templateModal" class="modal" style="display: none;">
    <div class="modal-content" style="max-width: 850px; width: 90%;">
        <div class="modal-header">
            <h2 id="modalTitle">æ–°å»ºæ¯ç‰ˆ</h2>
            <button class="close" id="closeModal" type="button">&times;</button>
        </div>
        <div class="modal-body">
            <form id="templateForm">
                <div class="form-group">
                    <label for="templateName">æ¨¡æ¿åç§° *</label>
                    <input type="text" id="templateName" name="template_name" required>
                </div>

                <div class="form-group">
                    <label for="templateDescription">æè¿°</label>
                    <textarea id="templateDescription" name="description" rows="3"></textarea>
                </div>

                <div class="form-group">
                    <label for="templateTags">æ ‡ç­¾ (ç”¨é€—å·åˆ†éš”)</label>
                    <input type="text" id="templateTags" name="tags" placeholder="ä¾‹å¦‚: å•†åŠ¡, ç®€çº¦, ç°ä»£">
                </div>

                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="isDefault" name="is_default">
                        è®¾ä¸ºé»˜è®¤æ¨¡æ¿
                    </label>
                </div>

                <div class="form-group">
                    <label for="htmlTemplate">HTMLæ¨¡æ¿ä»£ç  *</label>
                    <textarea id="htmlTemplate" name="html_template" required rows="15" style="font-family: 'Fira Code', 'Monaco', 'Consolas', monospace; font-size: 13px; line-height: 1.4;"></textarea>
                </div>

                <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                    <button type="button" id="previewTemplateBtn" class="btn btn-secondary">ğŸ‘ï¸ é¢„è§ˆ</button>
                    <button type="button" id="cancelBtn" class="btn btn-secondary">å–æ¶ˆ</button>
                    <button type="submit" class="btn btn-primary">ğŸ’¾ ä¿å­˜</button>
                </div>
            </form>
        </div>
    </div>
</div>

<!-- AI Generation Modal -->
<div id="aiGenerationModal" class="modal" style="display: none;">
    <div class="modal-content" style="max-width: 850px; width: 90%;">
        <div class="modal-header">
            <h2>AIç”Ÿæˆæ¯ç‰ˆ</h2>
            <button class="close" id="closeAIModal" type="button">&times;</button>
        </div>
        <div class="modal-body">
            <!-- è¡¨å•åŒºåŸŸ -->
            <div id="aiFormContainer">
                <form id="aiGenerationForm">
                    <div class="form-group">
                        <label for="aiPrompt">æè¿°æ‚¨æƒ³è¦çš„æ¯ç‰ˆé£æ ¼ *</label>
                        <textarea id="aiPrompt" name="prompt" required rows="4" placeholder="ä¾‹å¦‚: åˆ›å»ºä¸€ä¸ªç°ä»£ç®€çº¦é£æ ¼çš„å•†åŠ¡PPTæ¯ç‰ˆï¼Œä½¿ç”¨è“è‰²ä¸»è‰²è°ƒï¼ŒåŒ…å«å¡ç‰‡å¼å¸ƒå±€..."></textarea>
                    </div>

                    <div class="form-group">
                        <label for="aiTemplateName">æ¨¡æ¿åç§° *</label>
                        <input type="text" id="aiTemplateName" name="template_name" required>
                    </div>

                    <div class="form-group">
                        <label for="aiTemplateDescription">æè¿°</label>
                        <textarea id="aiTemplateDescription" name="description" rows="2"></textarea>
                    </div>

                    <div class="form-group">
                        <label for="aiTemplateTags">æ ‡ç­¾ (ç”¨é€—å·åˆ†éš”)</label>
                        <input type="text" id="aiTemplateTags" name="tags" placeholder="AIç”Ÿæˆ, ç°ä»£, å•†åŠ¡">
                    </div>

                    <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                        <button type="button" id="cancelAIBtn" class="btn btn-secondary">å–æ¶ˆ</button>
                        <button type="submit" class="btn btn-success">ğŸ¤– ç”Ÿæˆ</button>
                    </div>
                </form>
            </div>

            <!-- AIç”Ÿæˆè¿›åº¦åŒºåŸŸ -->
            <div id="aiGenerationProgress" style="display: none;">
                <div class="ai-generation-header">
                    <h3 style="margin: 0; color: var(--text-primary); font-size: 1.3rem;">ğŸ¤– AIæ­£åœ¨ç”Ÿæˆæ‚¨çš„æ¨¡æ¿...</h3>
                    <div class="generation-status">
                        <div class="status-indicator">
                            <div class="status-dot"></div>
                            <span id="statusText">æ­£åœ¨åˆ†æéœ€æ±‚...</span>
                        </div>
                    </div>
                </div>

                <div class="ai-response-container">
                    <div class="response-header">
                        <h4>ğŸ’­ AIæ€è€ƒè¿‡ç¨‹</h4>
                    </div>
                    <div id="aiResponseStream" class="ai-response-stream">
                        <!-- æµå¼AIå›åº”å°†åœ¨è¿™é‡Œæ˜¾ç¤º -->
                    </div>
                </div>

                <div class="generation-actions" style="margin-top: 20px; text-align: center;">
                    <button type="button" id="cancelGenerationBtn" class="btn btn-secondary">â¹ï¸ å–æ¶ˆç”Ÿæˆ</button>
                </div>
            </div>

            <!-- ç”Ÿæˆå®ŒæˆåŒºåŸŸ -->
            <div id="aiGenerationComplete" style="display: none;">
                <div class="completion-header">
                    <h3 style="margin: 0; color: #28a745; font-size: 1.2rem;">âœ… æ¨¡æ¿ç”Ÿæˆå®Œæˆï¼</h3>
                </div>

                <div class="completion-actions" style="margin-top: 20px; text-align: center; display: flex; gap: 10px; justify-content: center;">
                    <button type="button" id="viewGeneratedTemplateBtn" class="btn btn-primary">ğŸ‘ï¸ æŸ¥çœ‹æ¨¡æ¿</button>
                    <button type="button" id="closeCompletionBtn" class="btn btn-secondary">å…³é—­</button>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Preview Modal -->
<div id="previewModal" class="modal" style="display: none;">
    <div class="modal-content" style="max-width: 96vw; width: 96vw; height: 96vh;">
        <div class="modal-header">
            <h2>æ¨¡æ¿é¢„è§ˆ</h2>
            <button class="close" id="closePreviewModal" type="button">&times;</button>
        </div>
        <div class="modal-body" style="padding: 16px;">
            <div id="previewFrameContainer" style="display:flex; align-items:center; justify-content:center; width:100%; height: calc(96vh - 80px);">
                <iframe id="previewFrame" width="{{ aspect_ratio_settings.width }}" height="{{ aspect_ratio_settings.height }}" style="border: 1px solid var(--glass-border); background: var(--panel-bg); transform: scale(1); transform-origin: center center; margin: 0 auto; display:block; will-change: transform; border-radius:4px;"></iframe>
            </div>
        </div>
    </div>
</div>

<style>
/* åŠ¨ç”»å®šä¹‰ */
@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
}

/* åŠ è½½æŒ‡ç¤ºå™¨æ ·å¼ */
.loading-container {
    text-align: center;
    padding: 60px 40px;
    background: var(--glass-bg);
    backdrop-filter: blur(20px);
    border: 1px solid var(--glass-border);
    border-radius: var(--border-radius-lg);
    margin: 40px 0;
}

.loading-spinner {
    display: inline-block;
    width: 48px;
    height: 48px;
    border: 4px solid rgba(102, 126, 234, 0.2);
    border-top: 4px solid #667eea;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-bottom: 16px;
}

.loading-text {
    margin: 0;
    color: var(--text-secondary);
    font-size: 1rem;
    font-weight: 500;
    animation: pulse 2s ease-in-out infinite;
}

/* ç°ä»£åŒ–æ¨¡æ€æ¡†æ ·å¼ - ä¼˜åŒ–èƒŒæ™¯å’Œå®šä½ */
.modal {
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
    backdrop-filter: blur(8px);
    display: grid;
    place-items: center;
    animation: modalFadeIn 0.3s ease-out;
    padding: 20px;
    box-sizing: border-box;
    overflow: auto;
}

/* é¢„è§ˆæ¨¡æ€æ¡†éœ€è¦æ›´é«˜çš„z-index */
#previewModal {
    z-index: 1100;
}

@keyframes modalFadeIn {
    from {
        opacity: 0;
        backdrop-filter: blur(0px);
    }
    to {
        opacity: 1;
        backdrop-filter: blur(8px);
    }
}

.modal-content {
    background: var(--glass-bg);
    border: 1px solid var(--glass-border);
    border-radius: var(--border-radius-lg);
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    animation: modalSlideIn 0.3s ease-out;
    overflow: hidden;
    max-height: calc(100vh - 40px);
    overflow-y: auto;
    position: relative;
    margin: 0 auto;
    min-width: 320px;
}

@keyframes modalSlideIn {
    from {
        transform: translateY(-30px) scale(0.95);
        opacity: 0;
    }
    to {
        transform: translateY(0) scale(1);
        opacity: 1;
    }
}

.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 20px 24px;
    border-bottom: 1px solid var(--glass-border);
    background: var(--glass-bg);
    position: sticky;
    top: 0;
    z-index: 10;
}

.modal-header h2 {
    margin: 0;
    color: var(--text-primary);
    font-size: 1.4rem;
    font-weight: 700;
}

.close {
    font-size: 20px;
    font-weight: bold;
    cursor: pointer;
    color: var(--text-secondary);
    transition: all 0.3s ease;
    padding: 6px;
    border-radius: var(--border-radius-sm);
    display: flex;
    align-items: center;
    justify-content: center;
    width: 32px;
    height: 32px;
    background: rgba(0, 0, 0, 0.05);
    border: none;
}

.close:hover {
    color: var(--text-primary);
    background: rgba(0, 0, 0, 0.1);
    transform: scale(1.05);
}

.modal-body {
    padding: 24px;
    background: var(--glass-bg);
    display: flex;
    align-items: center;
    justify-content: center;
}

/* Allow preview iframe in modal to be absolutely positioned and sized by JS */
.modal-body iframe {
    max-width: none !important;
    max-height: none !important;
}

/* Ensure preview container enforces clipping and a neutral background so oversized content doesn't overflow visually */
#previewFrameContainer {
    background: var(--panel-bg);
    border-radius: 6px;
    box-sizing: border-box;
}

.template-card {
    background: var(--glass-bg);
    border: 1px solid var(--glass-border);
    border-radius: var(--border-radius-md);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    overflow: hidden;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    display: flex;
    flex-direction: column;
    height: auto;
    position: relative;
}

/* Highlight briefly when a template becomes the new default */
.template-card.default-highlight {
    animation: defaultHighlight 1.2s ease-in-out;
    box-shadow: 0 12px 30px rgba(102,118,234,0.25);
    border-color: rgba(102,118,234,0.6);
}

@keyframes defaultHighlight {
    0% { transform: translateY(-6px) scale(1.01); }
    50% { transform: translateY(-3px) scale(1.005); }
    100% { transform: translateY(0) scale(1); }
}

.template-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 3px;
    background: linear-gradient(135deg, #667eea, #764ba2);
    transform: scaleX(0);
    transition: transform 0.3s ease;
}

.template-card:hover {
    transform: translateY(-4px);
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
}

.template-card:hover::before {
    transform: scaleX(1);
}

.template-preview {
    width: 356px !important; /* 16:9æ¯”ä¾‹ï¼Œå®½åº¦å¤§äºé«˜åº¦ */
    height: 200px !important;
    background: var(--panel-bg);
    position: relative;
    border-bottom: 1px solid var(--glass-border);
    overflow: hidden;
    border-radius: var(--border-radius-md) var(--border-radius-md) 0 0;
    flex-shrink: 0;
    margin: 0 auto; /* center the preview horizontally inside the card */
}

.template-preview-iframe {
    width: 960px;
    height: 540px;
    border: none;
    pointer-events: none;
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    opacity: 0;
    transition: transform 180ms ease-out, opacity 180ms ease-out;
    transform-origin: center center;
    border-radius: 4px;
}

.preview-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0);
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: background-color 0.3s ease;
}

.preview-overlay:hover {
    background: rgba(0, 0, 0, 0.1);
}

.preview-overlay-text {
    background: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 8px 12px;
    border-radius: 4px;
    font-size: 12px;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.preview-overlay:hover .preview-overlay-text {
    opacity: 1;
}

.template-info {
    padding: 14px;
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
}

/* Place small metadata (usage/creator) and allow a delete button to sit to its right */
.info-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
    margin-top: 8px;
    flex-wrap: wrap;
}
.info-text {
    font-size: 12px;
    color: #999;
}
.info-delete {
    flex: 0 0 auto;
}

    .template-actions {
    padding: 12px 14px;
    border-top: 1px solid var(--glass-border);
    background: var(--glass-bg);
    display: flex;
    gap: 8px;
    justify-content: center; /* center action buttons under the card */
    align-items: center;
    flex-wrap: wrap; /* allow wrapping to avoid overflow */
    box-sizing: border-box;
    overflow: visible;
}

    /* Ensure individual buttons don't wrap their text and don't shrink too far */
    .template-actions .btn {
        white-space: nowrap;
        flex-shrink: 0;
    }

/* ç°ä»£åŒ–æ ‡ç­¾å’Œå¾½ç« æ ·å¼ */
.tag {
    display: inline-block;
    background: rgba(102, 126, 234, 0.1);
    color: #667eea;
    padding: 4px 12px;
    border-radius: var(--border-radius-sm);
    font-size: 0.75rem;
    font-weight: 500;
    margin-right: 6px;
    margin-bottom: 6px;
    border: 1px solid rgba(102, 126, 234, 0.2);
    backdrop-filter: blur(10px);
    transition: all 0.3s ease;
}

.tag:hover {
    background: rgba(102, 126, 234, 0.15);
    transform: translateY(-1px);
}

.default-badge {
    background: var(--success-gradient);
    color: white;
    padding: 4px 12px;
    border-radius: var(--border-radius-sm);
    font-size: 0.7rem;
    font-weight: 600;
    box-shadow: 0 2px 8px rgba(67, 233, 123, 0.3);
    border: 1px solid rgba(255, 255, 255, 0.2);
    backdrop-filter: blur(10px);
}

/* ç°ä»£åŒ–æŒ‰é’®æ ·å¼ - ä¼˜åŒ–é—´è·å’Œä¸€è‡´æ€§ï¼ˆä½œç”¨åŸŸé™å®šåˆ°æœ¬é¡µå®¹å™¨ï¼Œé¿å…å½±å“é¡¶éƒ¨å¯¼èˆªä¸»é¢˜æŒ‰é’®ï¼‰ */
.global-master-page .btn {
    padding: 10px 18px;
    border: none;
    border-radius: var(--border-radius-sm);
    cursor: pointer;
    font-size: 0.85rem;
    font-weight: 600;
    text-decoration: none;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    text-align: center;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    position: relative;
    overflow: hidden;
    border: 1px solid rgba(0, 0, 0, 0.1);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    white-space: nowrap;
    min-height: 38px;
}

.global-master-page .btn::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
    transition: left 0.5s;
}

.global-master-page .btn:hover::before {
    left: 100%;
}

.global-master-page .btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
}

.global-master-page .btn:active {
    transform: translateY(0);
}

.global-master-page .btn-primary {
    background: var(--primary-gradient);
    color: white;
    box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
}
.global-master-page .btn-primary:hover {
    box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
    transform: translateY(-2px) scale(1.02);
}

.global-master-page .btn-success {
    background: var(--success-gradient);
    color: white;
    box-shadow: 0 4px 15px rgba(67, 233, 123, 0.3);
}
.global-master-page .btn-success:hover {
    box-shadow: 0 8px 25px rgba(67, 233, 123, 0.4);
    transform: translateY(-2px) scale(1.02);
}

.global-master-page .btn-secondary {
    background: linear-gradient(135deg, #6c757d, #5a6268);
    color: white;
    box-shadow: 0 4px 15px rgba(108, 117, 125, 0.3);
}
.global-master-page .btn-secondary:hover {
    box-shadow: 0 8px 25px rgba(108, 117, 125, 0.4);
    transform: translateY(-2px) scale(1.02);
}

.global-master-page .btn-danger {
    background: var(--secondary-gradient);
    color: white;
    box-shadow: 0 4px 15px rgba(240, 147, 251, 0.3);
}
.global-master-page .btn-danger:hover {
    box-shadow: 0 8px 25px rgba(240, 147, 251, 0.4);
    transform: translateY(-2px) scale(1.02);
}

.global-master-page .btn-warning {
    background: var(--warning-gradient);
    color: white;
    box-shadow: 0 4px 15px rgba(255, 193, 7, 0.3);
}
.global-master-page .btn-warning:hover {
    box-shadow: 0 8px 25px rgba(255, 193, 7, 0.4);
    transform: translateY(-2px) scale(1.02);
}

.global-master-page .btn-info {
    background: linear-gradient(135deg, #17a2b8, #138496);
    color: white;
    box-shadow: 0 4px 15px rgba(23, 162, 184, 0.3);
}
.global-master-page .btn-info:hover {
    box-shadow: 0 8px 25px rgba(23, 162, 184, 0.4);
    transform: translateY(-2px) scale(1.02);
}

.global-master-page .btn-sm {
    padding: 6px 12px;
    font-size: 0.75rem;
    border-radius: var(--border-radius-sm);
    white-space: nowrap;
    min-width: auto;
    min-height: 32px;
    gap: 4px;
}

/* Action group helpers: keep main actions centered and the destructive action pinned to the right edge */
.template-actions {
    display: flex;
    align-items: center;
    justify-content: space-between; /* center group appears centered while delete is on right */
    gap: 12px;
}

.template-actions .action-center {
    display: flex;
    gap: 8px;
    justify-content: center;
    align-items: center;
    flex: 1 1 auto; /* allow center group to take available space and wrap */
    flex-wrap: wrap;
}

.template-actions .action-right {
    display: flex;
    align-items: center;
    justify-content: flex-end;
    flex: 0 0 auto;
}

/* AIç”Ÿæˆè¿›åº¦æ ·å¼ - ä¼˜åŒ–èƒŒæ™¯å’Œå¯è¯»æ€§ */
.ai-generation-header {
    text-align: center;
    margin-bottom: 20px;
    padding: 18px;
    background: var(--glass-bg);
    border-radius: var(--border-radius-md);
    border: 1px solid var(--glass-border);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
}

.generation-status {
    margin-top: 10px;
}

.status-indicator {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    font-size: 0.95rem;
    color: var(--text-primary);
}

.status-dot {
    width: 10px;
    height: 10px;
    background: #667eea;
    border-radius: 50%;
    animation: statusPulse 2s ease-in-out infinite;
}

@keyframes statusPulse {
    0%, 100% {
        transform: scale(1);
        opacity: 1;
    }
    50% {
        transform: scale(1.2);
        opacity: 0.7;
    }
}

.ai-response-container {
    background: var(--glass-bg);
    border: 1px solid var(--glass-border);
    border-radius: var(--border-radius-md);
    padding: 18px;
    margin: 18px 0;
    max-height: 400px;
    overflow-y: auto;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
}

.response-header {
    margin-bottom: 14px;
    padding-bottom: 10px;
    border-bottom: 1px solid rgba(0, 0, 0, 0.1);
}

.response-header h4 {
    margin: 0;
    color: var(--text-primary);
    font-size: 1.05rem;
    font-weight: 600;
}

.ai-response-stream {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    line-height: 1.6;
    color: var(--text-primary);
    font-size: 0.9rem;
    white-space: pre-wrap;
    word-wrap: break-word;
}

.ai-response-stream .typing-cursor {
    display: inline-block;
    width: 2px;
    height: 1.2em;
    background: #667eea;
    animation: blink 1s infinite;
    margin-left: 2px;
}

@keyframes blink {
    0%, 50% { opacity: 1; }
    51%, 100% { opacity: 0; }
}

.completion-header {
    text-align: center;
    margin-bottom: 20px;
    padding: 18px;
    background: var(--glass-bg);
    border-radius: var(--border-radius-md);
    border: 1px solid rgba(40, 167, 69, 0.3);
    box-shadow: 0 2px 8px rgba(40, 167, 69, 0.1);
}

/* å“åº”å¼è®¾è®¡ - ä¼˜åŒ–ç§»åŠ¨ç«¯ä½“éªŒ */
@media (max-width: 1200px) {
    #templatesGrid {
        grid-template-columns: repeat(auto-fill, minmax(340px, 1fr)) !important;
        gap: var(--spacing-md) !important;
    }

    .search-filter-container {
        flex-direction: column;
        gap: var(--spacing-sm);
    }

    .search-input-wrapper, .filter-wrapper {
        min-width: 100%;
    }
}

@media (max-width: 768px) {
    .templates-hero {
        padding: var(--spacing-md) var(--spacing-md);
    }

    .templates-hero h1 {
        font-size: 1.5rem;
    }

    .templates-hero p {
        font-size: 1rem;
    }

    .templates-header {
        flex-direction: column;
        gap: var(--spacing-md);
        align-items: stretch;
    }

    .templates-actions {
        flex-direction: column;
        width: 100%;
        gap: var(--spacing-sm);
    }

    .templates-actions .btn {
        width: 100%;
        justify-content: center;
    }

    #templatesGrid {
        grid-template-columns: 1fr !important;
        gap: var(--spacing-md) !important;
    }

    /* mobile: keep preview height unchanged (avoid empty rule) */

    .template-preview-iframe {
        transform: translate(-50%, -50%);
        transition: transform 180ms ease-out !important;
    }

    .template-actions {
        /* Keep buttons on a single line on narrow screens too; allow horizontal scroll if needed */
        flex-direction: row !important;
        flex-wrap: nowrap !important;
        overflow-x: auto !important;
        -webkit-overflow-scrolling: touch !important;
        gap: 6px !important;
        justify-content: flex-end !important;
    }

    .btn-sm {
        width: 100% !important;
        text-align: center !important;
        justify-content: center !important;
    }

    /* Buttons inside template cards' action bars should not become full-width on mobile
       â€” keep them inline and allow horizontal scrolling if necessary. */
    .template-card .template-actions .btn-sm {
        width: auto !important;
        min-width: 0 !important;
        white-space: nowrap !important;
        flex-shrink: 0 !important;
    }

    .modal-content {
        width: 95% !important;
        margin: 10px;
        max-height: calc(100vh - 20px) !important;
    }

    .modal-body {
        padding: 16px;
    }

    .search-filter-container {
        padding: var(--spacing-sm);
    }

    .modal {
        align-items: flex-start !important;
        padding: 10px !important;
    }
}

/* åˆ†é¡µæ ·å¼ */
.pagination-wrapper {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: var(--glass-bg);
    border: 1px solid var(--glass-border);
    border-radius: var(--border-radius-md);
    padding: var(--spacing-md);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    flex-wrap: wrap;
    gap: var(--spacing-sm);
}

.pagination-info {
    color: var(--text-secondary);
    font-size: 0.9rem;
    font-weight: 500;
}

.pagination-controls {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
}

.page-numbers {
    display: flex;
    gap: 4px;
}

.page-number {
    padding: 6px 12px;
    border: 1px solid var(--glass-border);
    border-radius: var(--border-radius-sm);
    background: var(--glass-bg);
    color: var(--text-primary);
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 0.85rem;
    font-weight: 500;
    min-width: 36px;
    text-align: center;
}

.page-number:hover {
    background: var(--panel-bg);
    border-color: #667eea;
}

.page-number.active {
    background: #667eea;
    color: white;
    border-color: #667eea;
}

.page-number.disabled {
    opacity: 0.5;
    cursor: not-allowed;
    pointer-events: none;
}

.pagination-size {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    font-size: 0.9rem;
    color: var(--text-secondary);
}

.pagination-size label {
    margin: 0;
    font-weight: 500;
}

.pagination-size select {
    padding: 4px 8px;
    font-size: 0.85rem;
}

/* å“åº”å¼åˆ†é¡µ */
@media (max-width: 768px) {
    .pagination-wrapper {
        flex-direction: column;
        align-items: stretch;
        gap: var(--spacing-sm);
    }

    .pagination-controls {
        justify-content: center;
    }

    .pagination-info,
    .pagination-size {
        text-align: center;
    }

    .page-numbers {
        justify-content: center;
        flex-wrap: wrap;
    }
}
</style>

<script>
// Global variables
let templates = [];
let editingTemplateId = null;
let currentPage = 1;
let pageSize = 6; // é»˜è®¤æ¯é¡µæ˜¾ç¤º6ä¸ªï¼Œæ›´å®¹æ˜“çœ‹åˆ°åˆ†é¡µæ•ˆæœ
let totalPages = 1;
let totalCount = 0;
let currentSearch = '';
let currentTag = '';

// Lightweight logger wrapper: control verbosity via ?debug=1 or window.__gm_debug = true
(function(){
    try {
        const urlParams = new URLSearchParams(window.location.search);
        const debugOn = urlParams.get('debug') === '1' || !!window.__gm_debug;
        window.__gm_log = {
            debug: function(){ if (debugOn) console.debug.apply(console, arguments); },
            info: function(){ if (debugOn) console.info.apply(console, arguments); },
            warn: function(){ console.warn.apply(console, arguments); },
            error: function(){ console.error.apply(console, arguments); }
        };
    } catch (e) { window.__gm_log = { debug:()=>{}, info:()=>{}, warn:()=>{}, error:()=>{} }; }
})();

// Allow cancelling pending preview loads to avoid blocking navigation when user changes page
window.__gm_cancelPendingPreviews = function(){
    try {
        const s = window.__previewLoadState;
        if (!s) return;
        try { s.observer && s.observer.disconnect(); } catch(e){}
        // clear queue
        try { s.queue = []; } catch(e){}
        // abort ongoing fetches
        try {
            if (Array.isArray(s.abortControllers)) {
                s.abortControllers.forEach(c => { try{ c.abort(); }catch(e){} });
            }
        } catch(e){}
        // revoke blob urls
        try {
            if (Array.isArray(s.blobUrls)) {
                s.blobUrls.forEach(u => { try{ URL.revokeObjectURL(u); }catch(e){} });
            }
        } catch(e){}
        // reset state
        window.__previewLoadState = { queue: [], running: 0, abortControllers: [], blobUrls: [] };
    } catch(e) { /* noop */ }
};

// Initialize page
document.addEventListener('DOMContentLoaded', function() {
    loadTemplates(1);
    setupEventListeners();
});

function setupEventListeners() {
    // Modal controls
    document.getElementById('createTemplateBtn').addEventListener('click', () => openTemplateModal());
    document.getElementById('generateWithAIBtn').addEventListener('click', () => openAIGenerationModal());
    document.getElementById('closeModal').addEventListener('click', () => closeTemplateModal());
    document.getElementById('closeAIModal').addEventListener('click', () => closeAIGenerationModal());
    document.getElementById('closePreviewModal').addEventListener('click', () => closePreviewModal());
    document.getElementById('cancelBtn').addEventListener('click', () => closeTemplateModal());
    document.getElementById('cancelAIBtn').addEventListener('click', () => closeAIGenerationModal());

    // AIç”Ÿæˆç›¸å…³æŒ‰é’®
    document.getElementById('cancelGenerationBtn').addEventListener('click', () => {
        // å–æ¶ˆç”Ÿæˆå¹¶è¿”å›è¡¨å•
        document.getElementById('aiGenerationProgress').style.display = 'none';
        document.getElementById('aiFormContainer').style.display = 'block';
    });

    document.getElementById('closeCompletionBtn').addEventListener('click', () => {
        closeAIGenerationModal();
        loadTemplates(1); // åˆ·æ–°æ¨¡æ¿åˆ—è¡¨ï¼Œå›åˆ°ç¬¬ä¸€é¡µ
    });

    // Form submissions
    document.getElementById('templateForm').addEventListener('submit', handleTemplateSubmit);
    document.getElementById('aiGenerationForm').addEventListener('submit', handleAIGeneration);

    // Preview button
    document.getElementById('previewTemplateBtn').addEventListener('click', previewTemplate);

    // Import functionality
    document.getElementById('importTemplateInput').addEventListener('change', handleTemplateImport);

    // Filters
    document.getElementById('searchInput').addEventListener('input', debounce(handleSearch, 500));
    document.getElementById('tagFilter').addEventListener('change', handleTagFilter);
    document.getElementById('refreshBtn').addEventListener('click', () => loadTemplates(1));

    // Pagination
    document.getElementById('prevPageBtn').addEventListener('click', () => loadTemplates(currentPage - 1));
    document.getElementById('nextPageBtn').addEventListener('click', () => loadTemplates(currentPage + 1));
    document.getElementById('pageSizeSelect').addEventListener('change', handlePageSizeChange);

    // Close modals when clicking outside
    window.addEventListener('click', function(event) {
        if (event.target.classList.contains('modal')) {
            event.target.style.display = 'none';
        }
    });

    // Close preview modal on Escape key
    window.addEventListener('keydown', function(event) {
        if (event.key === 'Escape') {
            const previewModal = document.getElementById('previewModal');
            if (previewModal && previewModal.style.display && previewModal.style.display !== 'none') {
                previewModal.style.display = 'none';
            }
        }
    });
}

async function loadTemplates(page = 1) {
    // Cancel any pending preview loads to make user navigation responsive
    try { window.__gm_cancelPendingPreviews(); } catch(e){}
    // init state
    window.__previewLoadState = window.__previewLoadState || { queue: [], running: 0, abortControllers: [], blobUrls: [] };
    showLoading(true);
    // Clear preview cache so updated templates (like ç»ˆç«¯é£) refresh immediately
    window.__templateDetailCache = new Map();
    window.__previewAlignments = window.__previewAlignments || new Map();
    try {
        // Build query parameters
        const params = new URLSearchParams({
            active_only: 'true',
            page: page.toString(),
            page_size: pageSize.toString()
        });

        if (currentSearch) {
            params.append('search', currentSearch);
        }

        if (currentTag) {
            params.append('tags', currentTag);
        }

        const response = await fetch(`/api/global-master-templates/?${params}`);

        if (!response.ok) {
            throw new Error('Failed to load templates');
        }

        const data = await response.json();
        templates = data.templates;

        // Update pagination info
        currentPage = data.pagination.current_page;
        totalPages = data.pagination.total_pages;
        totalCount = data.pagination.total_count;



        renderTemplates(templates);
        updatePagination();
        updateTagFilter();
    } catch (error) {
        console.error('Error loading templates:', error);
        alert('åŠ è½½æ¨¡æ¿å¤±è´¥: ' + error.message);
    } finally {
        showLoading(false);
    }
}

function renderTemplates(templatesToRender) {
    const grid = document.getElementById('templatesGrid');

    if (templatesToRender.length === 0) {
        grid.innerHTML = `
            <div style="grid-column: 1 / -1; text-align: center; padding: 40px; color: #666;">
                <h3>æš‚æ— æ¨¡æ¿</h3>
                <p>ç‚¹å‡»"æ–°å»ºæ¯ç‰ˆ"æˆ–"AIç”Ÿæˆæ¯ç‰ˆ"æ¥åˆ›å»ºç¬¬ä¸€ä¸ªæ¨¡æ¿</p>
            </div>
        `;
        return;
    }
    
    grid.innerHTML = templatesToRender.map((template, index) => `
        <div class="template-card">
            <div class="template-preview" id="preview-${template.id}">
                <iframe
                    class="template-preview-iframe"
                    id="iframe-${template.id}"
                    onload="adjustIframeContent(${template.id})"
                ></iframe>
                <div class="preview-overlay" onclick="previewTemplateById(${template.id})" ondblclick="cyclePreviewAlign(${template.id}); return false;" title="ç‚¹å‡»æŸ¥çœ‹å®Œæ•´é¢„è§ˆï¼ŒåŒå‡»åˆ‡æ¢å¡«å……å¯¹é½ï¼ˆå±…ä¸­/ä¸Š/ä¸‹/å·¦/å³ï¼‰">
                    <div class="preview-overlay-text"><i class="fas fa-search-plus"></i> ç‚¹å‡»æ”¾å¤§é¢„è§ˆ</div>
                </div>
            </div>
            <div class="template-info">
                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
                    <h4 style="margin: 0; color: #2c3e50; font-size: 16px;">${template.template_name}</h4>
                    ${template.is_default ? '<span class="default-badge">é»˜è®¤</span>' : ''}
                </div>
                <p style="margin: 0 0 8px 0; color: #666; font-size: 14px; line-height: 1.4;">${template.description || 'æš‚æ— æè¿°'}</p>
                <div style="margin-bottom: 8px;">
                    ${template.tags.map(tag => `<span class="tag">${tag}</span>`).join('')}
                </div>
                <div style="font-size: 12px; color: #999;">
                    <div class="info-row">
                        <div class="info-text">ä½¿ç”¨æ¬¡æ•°: ${template.usage_count} | åˆ›å»ºè€…: ${template.created_by}</div>
                        <div class="info-delete">
                            ${!template.is_default ?
                                `<button class="btn btn-sm btn-success" onclick="setDefaultTemplate(${template.id})">â­ è®¾ä¸ºé»˜è®¤</button>` :
                                ''
                            }
                        </div>
                    </div>
                </div>
            </div>
            <div class="template-actions">
                <div class="action-center">
                    <button class="btn btn-sm btn-primary" onclick="editTemplate(${template.id})">âœï¸ ç¼–è¾‘</button>
                    <button class="btn btn-sm btn-warning" onclick="duplicateTemplate(${template.id})">ğŸ“‹ å¤åˆ¶</button>
                    <button class="btn btn-sm" style="background: #17a2b8; color: white;" onclick="exportTemplate(${template.id})">ğŸ“¤ å¯¼å‡º</button>
                    ${!template.is_default ?
                        `<button class="btn btn-sm btn-danger" onclick="deleteTemplate(${template.id})">ğŸ—‘ï¸ åˆ é™¤</button>` :
                        ''
                    }
                </div>
            </div>
        </div>
    `).join('');

    // Load template content into iframes after rendering
    // Lazy-load previews using IntersectionObserver with small delay
    setTimeout(() => {
        // More conservative concurrency to avoid many simultaneous iframe loads
        const maxConcurrent = 1;
        const state = window.__previewLoadState = window.__previewLoadState || { queue: [], running: 0, abortControllers: [], blobUrls: [] };
        const cache = window.__templateDetailCache = window.__templateDetailCache || new Map();

        function next() {
            if (state.running >= maxConcurrent || state.queue.length === 0) return;
            const fn = state.queue.shift();
            state.running++;
            // run the queued load; allow micro-yielding so UI stays responsive
            const run = () => fn().finally(() => { state.running--; setTimeout(next, 0); });
            // schedule run in idle time if available, otherwise run immediately
            if (window.requestIdleCallback) {
                try { window.requestIdleCallback(run, { timeout: 100 }); }
                catch(e) { run(); }
            } else {
                run();
            }
        }

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const el = entry.target;
                    const id = el.getAttribute('data-template-id');
                    try { observer.unobserve(el); } catch(e){}
                    state.queue.push(() => loadTemplatePreview(parseInt(id), cache));
                    next();
                }
            });
        }, { rootMargin: '100px' });

        state.observer = observer;

        templatesToRender.forEach(t => {
            const container = document.getElementById('preview-' + t.id);
            if (container) {
                container.setAttribute('data-template-id', t.id);
                observer.observe(container);
            }
        });
    }, 200);
}

async function loadTemplatePreview(templateId, cache) {
    try {
            window.__gm_log.info && window.__gm_log.info('Loading preview for template', templateId);
        let template;
        if (cache && cache.has(templateId)) {
            template = cache.get(templateId);
        } else {
            // Use AbortController so we can cancel in-flight preview loads
            const controller = new AbortController();
            try {
                if (!window.__previewLoadState) window.__previewLoadState = { abortControllers: [], blobUrls: [] };
                window.__previewLoadState.abortControllers.push(controller);
            } catch (e) { /* noop */ }
            let response;
            try {
                response = await fetch('/api/global-master-templates/' + templateId, { cache: 'no-store', signal: controller.signal });
            } catch (err) {
                // likely aborted
                window.__gm_log.info && window.__gm_log.info('Preview fetch aborted for', templateId);
                return;
            } finally {
                try {
                    // remove controller from state (if present)
                    if (window.__previewLoadState && Array.isArray(window.__previewLoadState.abortControllers)) {
                        const idx = window.__previewLoadState.abortControllers.indexOf(controller);
                        if (idx !== -1) window.__previewLoadState.abortControllers.splice(idx, 1);
                    }
                } catch (e) { /* noop */ }
            }
            if (!response || !response.ok) {
                console.warn('Failed to load template', templateId, 'for preview');
                showPreviewFallback(templateId);
                return;
            }
            template = await response.json();
            if (cache) cache.set(templateId, template);
        }
        const iframe = document.getElementById('iframe-' + templateId);

    window.__gm_log.info && window.__gm_log.info('Template', templateId, 'loaded:', template.template_name);

        if (iframe && template.html_template && template.html_template.trim()) {
            window.__gm_log.info && window.__gm_log.info('Setting up iframe for template', templateId);

            // ä½¿ç”¨å®é™…çš„æ¨¡æ¿HTMLå†…å®¹ï¼Œä½†æ·»åŠ ä¸€äº›ç¤ºä¾‹æ•°æ®
            let previewHtml = template.html_template || '';

            // æ›¿æ¢å¸¸è§æ¨¡æ¿å˜é‡ä¸ºç¤ºä¾‹å†…å®¹ï¼ˆå¢å¼ºè¦†ç›–ï¼‰
            const dateStr = new Date().toLocaleDateString();
            const replacements = [
                ['title', template.template_name || 'ç¤ºä¾‹æ ‡é¢˜'],
                ['main_title', template.template_name || 'ç¤ºä¾‹æ ‡é¢˜'],
                ['main_heading', template.template_name || 'ç¤ºä¾‹æ ‡é¢˜'],
                ['heading', template.template_name || 'ç¤ºä¾‹æ ‡é¢˜'],
                ['subtitle', 'å­æ ‡é¢˜'],
                ['subheading', 'å­æ ‡é¢˜'],
                ['content', 'è¿™æ˜¯æ¨¡æ¿é¢„è§ˆå†…å®¹'],
                ['body', 'è¿™æ˜¯æ¨¡æ¿é¢„è§ˆå†…å®¹'],
                ['author', 'FlowSlide'],
                ['company_name', 'Your Company'],
                ['username', 'User'],
                ['date', dateStr],
                ['footer', 'FlowSlide é¢„è§ˆ'],
                ['page', '1'],
                ['page_number', '1'],
                ['slide_number', '1'],
                ['current_slide', '1'],
                ['total_slides', '1'],
                ['total_pages', '1'],
                ['theme_color', '#4f46e5'],
                ['background_color', '#ffffff'],
                ['logo_url', '']
            ];
            replacements.forEach(([key, value]) => {
                try {
                    const re = new RegExp(`\\{\\{\\s*${key}\\s*\\}\\}`,'g');
                    previewHtml = previewHtml.replace(re, String(value));
                } catch (e) { /* noop */ }
            });

                // Inject a small preview-only CSS to encourage the main slide area to fill the iframe.
                // This is applied only to the preview blob and should not affect stored templates.
                const previewInjectCSS = `<style>
                    /* Ensure the root elements occupy the full iframe viewport */
                    html, html * { box-sizing: border-box !important; }
                    html, body { width:100% !important; height:100% !important; min-width:100% !important; min-height:100% !important; margin:0 !important; padding:0 !important; overflow:hidden !important; display:block !important; }
                    /* Ensure body direct children expand to fill the body so body size equals html size */
                    body > * { width:100% !important; height:100% !important; min-width:100% !important; min-height:100% !important; display:block !important; box-sizing:border-box !important; }
                    /* target common slide containers and wrapper classes to avoid narrow column layouts */
                    .slide, .ppt-slide, #root, .page, .slide-content,
                    .container, .wrap, .content, main, section, article,
                    .cols, .row, .column, .col, .inner {
                        width:100% !important;
                        height:100% !important;
                        min-width:100% !important;
                        min-height:100% !important;
                        max-width:none !important;
                        max-height:none !important;
                        display:block !important;
                        box-sizing:border-box !important;
                    }
                    /* images and SVGs should scale to container */
                    img, svg { max-width:100% !important; height:auto !important; }
                </style>`;

                // Lightweight script to encourage templates that initialized once to relayout
                const previewInjectScript = `<script>(function(){try{function __fs_fix(){try{document.documentElement.style.width='100%';document.documentElement.style.height='100%';document.body.style.width='100%';document.body.style.height='100%';}catch(e){}try{window.dispatchEvent(new Event('resize'));}catch(e){}setTimeout(function(){try{window.dispatchEvent(new Event('resize'));}catch(e){}},80);setTimeout(function(){try{window.dispatchEvent(new Event('resize'));}catch(e){}},300);setTimeout(function(){try{if(window && window.initSlides) try{window.initSlides();}catch(e){}; if(window && window.recalcLayout) try{window.recalcLayout();}catch(e){} }catch(e){}},500);}if(document.readyState==='complete'){__fs_fix();}else{window.addEventListener('load', __fs_fix);setTimeout(__fs_fix, 120);} }catch(e){} })()<\/script>`;

                try {
                    if (/\<head[^>]*\>/i.test(previewHtml)) {
                        previewHtml = previewHtml.replace(/\<head[^>]*\>/i, function(m) { return m + previewInjectCSS + previewInjectScript; });
                    } else if (/\<html[^>]*\>/i.test(previewHtml)) {
                        previewHtml = previewHtml.replace(/\<html([^>]*)\>/i, function(m) { return m + '<head>' + previewInjectCSS + previewInjectScript + '</head>'; });
                    }
                } catch (e) { /* noop - continue, wrapper below will include CSS/script */ }

            // ç¡®ä¿HTMLæœ‰åŸºæœ¬ç»“æ„
            if (!previewHtml.includes('<!DOCTYPE') && !previewHtml.includes('<html')) {
                previewHtml = `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { width: {{ aspect_ratio_settings.width }}px; height: {{ aspect_ratio_settings.height }}px; margin: 0; padding: 0; overflow: hidden; }
    </style>
    ${previewInjectCSS}
    ${previewInjectScript}
</head>
<body>
    ${previewHtml}
</body>
</html>`;
            }

            // Create a blob URL for the HTML content
            const blob = new Blob([previewHtml], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            try {
                if (!window.__previewLoadState) window.__previewLoadState = { abortControllers: [], blobUrls: [] };
                if (Array.isArray(window.__previewLoadState.blobUrls)) window.__previewLoadState.blobUrls.push(url);
            } catch (e) { /* noop */ }

            // Set up load handlers
            // Use a retrying measurement to avoid race conditions where inner layout isn't ready on first read.
            function measureAndApplyCardIframe(attemptsLeft) {
                try {
                    const container = document.getElementById('preview-' + templateId);
                    if (!container) return;
                    const rect = container.getBoundingClientRect();

                    // If container hasn't expanded to a sensible size yet, retry a few times
                    if (attemptsLeft > 0 && (rect.width < 200 || rect.height < 120)) {
                        setTimeout(() => measureAndApplyCardIframe(attemptsLeft - 1), 80 + (4 - attemptsLeft) * 60);
                        return;
                    }

                    const doCardMeasure = function() {
                        // Use fixed natural size for card previews to avoid measurement randomness
                        const contentW = 960;
                        const contentH = 540;

                        // Compute cover scale based on fixed natural size
                        const coverScale = Math.max(rect.width / contentW, rect.height / contentH);
                        const chosenScaleCard = Math.max(0.05, Math.min(20, coverScale));

                        // synchronize iframe intrinsic size attributes (intrinsic content size)
                        try { iframe.setAttribute('width', String(contentW)); iframe.setAttribute('height', String(contentH)); } catch (_) { /* noop */ }

                        // Instead of using CSS scale (which doesn't change layout box), set the rendered
                        // iframe width/height to the scaled pixel size so DevTools reported size matches visual size.
                        try {
                            const finalW = Math.max(8, Math.round(contentW * chosenScaleCard));
                            const finalH = Math.max(8, Math.round(contentH * chosenScaleCard));
                            iframe.style.width = finalW + 'px';
                            iframe.style.height = finalH + 'px';
                        } catch (_) { /* noop */ }

                        // keep centered translate but remove scale transform
                        try { iframe.style.transform = `translate(-50%, -50%)`; iframe.style.opacity = '1'; } catch(e){}
                    };

                    if (window.requestIdleCallback) {
                        try { window.requestIdleCallback(doCardMeasure, { timeout: 120 }); }
                        catch(e) { setTimeout(doCardMeasure, 0); }
                    } else {
                        setTimeout(doCardMeasure, 0);
                    }
                } catch (e) { /* noop */ }
            }

            iframe.onload = function() {
                // Apply fixed-size cover scale once loaded
                measureAndApplyCardIframe(0);
                setTimeout(function() { URL.revokeObjectURL(url); }, 2000);
            };

            iframe.onerror = function() {
                console.warn('Iframe failed to load for template', templateId);
                showPreviewFallback(templateId);
                URL.revokeObjectURL(url);
            };

            // Set an initial inline transform immediately using the same fixed natural size
            try {
                const container = document.getElementById('preview-' + templateId);
                if (container) {
                    const rect = container.getBoundingClientRect();
                    const naturalW = 960;
                    const naturalH = 540;
                    const initialScale = Math.max(rect.width / naturalW, rect.height / naturalH) || 0.32;
                    try {
                        const initialW = Math.max(8, Math.round(naturalW * initialScale));
                        const initialH = Math.max(8, Math.round(naturalH * initialScale));
                        iframe.style.width = initialW + 'px';
                        iframe.style.height = initialH + 'px';
                    } catch(_) {}
                    iframe.style.transform = `translate(-50%, -50%)`;
                    iframe.style.opacity = '1';
                    // set intrinsic attributes early
                    try { iframe.setAttribute('width', String(naturalW)); iframe.setAttribute('height', String(naturalH)); } catch(_) {}
                }
            } catch(e) { /* noop */ }

            // Set the src to trigger loading
            iframe.src = url;

            // Also attempt a quick measurement shortly after setting src in case onload fires earlier
            setTimeout(function() {
                try { measureAndApplyCardIframe(3); } catch(e) { /* noop */ }
            }, 80);

        } else {
            console.warn('No HTML template content for template', templateId);
            showPreviewFallback(templateId);
        }
    } catch (error) {
        console.error('Error loading preview for template', templateId, ':', error);
        showPreviewFallback(templateId);
    }
}

function showPreviewFallback(templateId) {
    const previewContainer = document.getElementById(`preview-${templateId}`);
    if (previewContainer) {
        previewContainer.innerHTML = `
            <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #999; font-size: 14px; flex-direction: column;">
                <div style="font-size: 24px; margin-bottom: 8px;">ğŸ“„</div>
                <div>æš‚æ— é¢„è§ˆ</div>
            </div>
        `;
    }
}

function adjustIframeContent(templateId) {
    // This function can be used to adjust iframe content after loading if needed
    // Currently just a placeholder for future enhancements
}

// Apply cover-style scaling for a preview iframe. Attempts to read iframe content size (same-origin) and
// falls back to a default natural size. Honors per-template alignment stored in window.__previewAlignments.
function applyCoverScaleForIframe(templateId, iframe) {
    const container = document.getElementById('preview-' + templateId);
    if (!container || !iframe) return;

    const rect = container.getBoundingClientRect();

    // Use fixed natural size for card previews to ensure stable, consistent cover behavior
    const naturalW_card = 960;
    const naturalH_card = 540;
    let contentW = naturalW_card, contentH = naturalH_card;

    // If alignment not set by user, pick a default by template orientation
    window.__previewAlignments = window.__previewAlignments || new Map();
    if (!window.__previewAlignments.has(templateId)) {
        const isLandscape = contentW >= contentH;
        window.__previewAlignments.set(templateId, isLandscape ? 'center' : 'top');
    }

    // ensure the iframe element reports the intrinsic content size we used for math
    try { iframe.setAttribute('width', contentW); iframe.setAttribute('height', contentH); } catch(e) {}
    try { iframe.style.width = contentW + 'px'; iframe.style.height = contentH + 'px'; } catch(e) {}

    // calculate cover scale based on the measured or natural card content size
    const coverScale = Math.max(rect.width / contentW, rect.height / contentH);
    const safeScale = Math.max(0.05, Math.min(20, coverScale));

    // alignment: center / top / bottom / left / right
    const align = (window.__previewAlignments && window.__previewAlignments.get(templateId)) || 'center';
    // Default center translate
    let tx = '-50%';
    let ty = '-50%';
    if (align === 'top') ty = '-20%';
    if (align === 'bottom') ty = '-80%';
    if (align === 'left') tx = '-20%';
    if (align === 'right') tx = '-80%';

    // Ensure container clips and is positioned for absolute child
    container.style.position = 'relative';
    container.style.overflow = 'hidden';

    // Position iframe absolutely and center, then scale (may crop)
    iframe.style.position = 'absolute';
    iframe.style.left = '50%';
    iframe.style.top = '50%';
    iframe.style.transformOrigin = 'center center';
    try {
        const finalW = Math.max(8, Math.round(contentW * safeScale));
        const finalH = Math.max(8, Math.round(contentH * safeScale));
        iframe.style.width = finalW + 'px';
        iframe.style.height = finalH + 'px';
    } catch (e) { /* noop */ }
    iframe.style.transform = `translate(${tx}, ${ty})`;
}

// Cycle preview alignment for a template: center -> top -> bottom -> left -> right -> center
function cyclePreviewAlign(templateId) {
    window.__previewAlignments = window.__previewAlignments || new Map();
    const order = ['center','top','bottom','left','right'];
    const cur = window.__previewAlignments.get(templateId) || 'center';
    const next = order[(order.indexOf(cur) + 1) % order.length];
    window.__previewAlignments.set(templateId, next);
    // apply immediately if iframe exists
    const iframe = document.getElementById('iframe-' + templateId);
    if (iframe) applyCoverScaleForIframe(templateId, iframe);
}

// Generic cover-scaling for an arbitrary iframe inside the modal preview container
function applyCoverScaleGeneric(frame) {
    const container = document.getElementById('previewFrameContainer');
    if (!container || !frame) return;
    const rect = container.getBoundingClientRect();

    // We'll attempt to measure the iframe content multiple times in case the inner layout hasn't settled.
    let attempts = 0;
    const maxAttempts = 6;

    function measureAndApply() {
        attempts++;
        let contentW = parseInt(frame.getAttribute('width')) || 1280;
        let contentH = parseInt(frame.getAttribute('height')) || 720;
        let measured = false;
        try {
            const doc = frame.contentDocument || frame.contentWindow.document;
            if (doc) {
                const body = doc.body || doc.documentElement;
                const bRect = body.getBoundingClientRect();
                // prefer measuring a common slide container if present
                const slideSelectors = ['.slide', '.ppt-slide', '#root', '.page', '.slide-content'];
                for (const sel of slideSelectors) {
                    try {
                        const el = doc.querySelector(sel);
                        if (el) {
                            const r = el.getBoundingClientRect();
                            if (r.width > 20 && r.height > 20) {
                                contentW = Math.max(contentW, Math.round(r.width));
                                contentH = Math.max(contentH, Math.round(r.height));
                                measured = true;
                                break;
                            }
                        }
                    } catch (innerSelE) { /* noop */ }
                }

                if (!measured) {
                    contentW = Math.max(contentW, Math.abs(bRect.width) || contentW);
                    contentH = Math.max(contentH, Math.abs(bRect.height) || contentH);
                    // if body is too small (e.g., only header strip), try scroll sizes
                    contentW = Math.max(contentW, body.scrollWidth || 0, body.offsetWidth || 0);
                    contentH = Math.max(contentH, body.scrollHeight || 0, body.offsetHeight || 0);
                }

                // set iframe intrinsic size to the measured content so scaling math is correct
                frame.style.width = contentW + 'px';
                frame.style.height = contentH + 'px';
            }
        } catch (e) {
            // cross-origin or other access denied - keep fallback sizes
        }

    // Clamp sizes to avoid extreme values
    contentW = Math.max(320, Math.min(4000, contentW));
    contentH = Math.max(240, Math.min(3000, contentH));

    // Compute both cover and contain scales. For modal preview prefer contain so content fits fully.
    const coverScale = Math.max(rect.width / contentW, rect.height / contentH);
    const containScale = Math.min(rect.width / contentW, rect.height / contentH);
    const isModal = container && container.id === 'previewFrameContainer';
    const chosenScale = isModal ? containScale : coverScale;
    const safeScale = Math.max(0.05, Math.min(20, chosenScale));

        container.style.position = 'relative';
        container.style.overflow = 'hidden';
        frame.style.position = 'absolute';

        // honor per-template alignment if present (modal may reuse window.__previewAlignments map)
        const align = (window.__previewAlignments && window.__previewAlignments.get && window.__previewAlignments.get('modal')) || 'center';
        let tx = '-50%';
        let ty = '-50%';
        if (align === 'top') ty = '-20%';
        if (align === 'bottom') ty = '-80%';
        if (align === 'left') tx = '-20%';
        if (align === 'right') tx = '-80%';

            frame.style.left = '50%';
            frame.style.top = '50%';
            frame.style.transformOrigin = 'center center';
            try {
                if (isModal) {
                    // For modal previews, make the iframe fill the container so inner content can use 100% sizing
                    frame.style.width = Math.max(8, Math.round(rect.width)) + 'px';
                    frame.style.height = Math.max(8, Math.round(rect.height)) + 'px';
                    // center exactly
                    tx = '-50%';
                    ty = '-50%';
                } else {
                    const finalW = Math.max(8, Math.round(contentW * safeScale));
                    const finalH = Math.max(8, Math.round(contentH * safeScale));
                    frame.style.width = finalW + 'px';
                    frame.style.height = finalH + 'px';
                }
            } catch(e) { /* noop */ }
            // keep translate for centering/alignment; modal uses translate(-50%,-50%) to center the full-size iframe
            frame.style.transform = `translate(${tx}, ${ty})`;
            try { frame.style.opacity = '1'; } catch(e) { /* noop */ }

        // If measured size seems like just a small header (height < 200) and we have attempts left, retry after a short delay
        if ((contentH < 200 || contentW < 200) && attempts < maxAttempts) {
            setTimeout(measureAndApply, 120 * attempts);
        }
    }

    measureAndApply();
}

// å¯¼å‡ºæ¨¡æ¿åŠŸèƒ½ - åœ¨HTMLä¸­å®šä¹‰ä»¥ä¾¿onclickå¯ä»¥è®¿é—®
async function exportTemplate(templateId) {
    try {
        // Abortable fetch so previews can be cancelled
        const controller = new AbortController();
        try {
            if (!window.__previewLoadState) window.__previewLoadState = { abortControllers: [], blobUrls: [] };
            window.__previewLoadState.abortControllers.push(controller);
        } catch (e) { /* noop */ }

        let response;
        try {
            response = await fetch(`/api/global-master-templates/${templateId}`, { signal: controller.signal });
        } catch (err) {
            window.__gm_log.info && window.__gm_log.info('Preview fetch aborted for modal', templateId);
            return;
        } finally {
            try {
                if (window.__previewLoadState && Array.isArray(window.__previewLoadState.abortControllers)) {
                    const idx = window.__previewLoadState.abortControllers.indexOf(controller);
                    if (idx !== -1) window.__previewLoadState.abortControllers.splice(idx, 1);
                }
            } catch (e) { /* noop */ }
        }

        if (!response || !response.ok) {
            throw new Error('Failed to load template');
        }

        const template = await response.json();

        // å‡†å¤‡å¯¼å‡ºæ•°æ®
        const exportData = {
            template_name: template.template_name,
            description: template.description,
            html_template: template.html_template,
            tags: template.tags,
            is_default: false, // å¯¼å‡ºæ—¶ä¸ä¿ç•™é»˜è®¤çŠ¶æ€
            export_info: {
                exported_at: new Date().toISOString(),
                original_id: template.id,
                original_created_at: template.created_at
            }
        };

        // åˆ›å»ºä¸‹è½½é“¾æ¥
        const dataStr = JSON.stringify(exportData, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });

    const link = document.createElement('a');
    const linkUrl = URL.createObjectURL(dataBlob);
    link.href = linkUrl;
        link.download = `${template.template_name}_${new Date().toISOString().split('T')[0]}.json`;

        // è§¦å‘ä¸‹è½½
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        // æ¸…ç†URL
        setTimeout(() => {
            try { URL.revokeObjectURL(linkUrl); }
            catch(e){}
        }, 1000);

    window.__gm_log.info && window.__gm_log.info('æ¨¡æ¿å¯¼å‡ºæˆåŠŸ:', template.template_name);

    } catch (error) {
        console.error('Error exporting template:', error);
        alert('å¯¼å‡ºæ¨¡æ¿å¤±è´¥: ' + error.message);
    }
}

// å…¶ä»–éœ€è¦åœ¨HTMLä¸­å®šä¹‰çš„å‡½æ•°ï¼Œä»¥ä¾¿onclickå¯ä»¥è®¿é—®
function editTemplate(templateId) {
    openTemplateModal(templateId);
}

async function duplicateTemplate(templateId) {
    const newName = prompt('è¯·è¾“å…¥æ–°æ¨¡æ¿çš„åç§°:');
    if (!newName || !newName.trim()) {
        return;
    }

    try {
        const response = await fetch(`/api/global-master-templates/${templateId}/duplicate?new_name=${encodeURIComponent(newName.trim())}`, {
            method: 'POST'
        });

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.detail || 'Failed to duplicate template');
        }

        loadTemplates(currentPage);
        alert('æ¨¡æ¿å¤åˆ¶æˆåŠŸï¼');
    } catch (error) {
        console.error('Error duplicating template:', error);
        alert('å¤åˆ¶æ¨¡æ¿å¤±è´¥: ' + error.message);
    }
}

async function setDefaultTemplate(templateId) {
    try {
        // Optimistic UI update: mark selected template as default locally so user sees immediate feedback
        const previousDefaults = templates.filter(t => t.is_default).map(t => t.id);
        templates.forEach(t => { t.is_default = (t.id === templateId); });
        renderTemplates(templates);

        // highlight the newly-default card if visible
        const card = document.querySelector('.template-card:nth-child(1)');
        const newCard = Array.from(document.querySelectorAll('.template-card')).find(el => el.querySelector(`[onclick='setDefaultTemplate(${templateId})']`) || el.querySelector(`[onclick="setDefaultTemplate(${templateId})"]`));
        if (newCard) {
            newCard.classList.add('default-highlight');
            setTimeout(() => newCard.classList.remove('default-highlight'), 1400);
            // if not visible, scroll it into view
            newCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        // Call server to set default
        const response = await fetch(`/api/global-master-templates/${templateId}/set-default`, { method: 'POST' });
        if (!response.ok) {
            // rollback optimistic update
            templates.forEach(t => { t.is_default = previousDefaults.includes(t.id); });
            renderTemplates(templates);
            const error = await response.json();
            throw new Error(error.detail || 'Failed to set default template');
        }

    // Reconcile with server: load page 1 (server sorts default first)
    setTimeout(() => loadTemplates(1), 500);
    } catch (error) {
        console.error('Error setting default template:', error);
        alert('è®¾ç½®é»˜è®¤æ¨¡æ¿å¤±è´¥: ' + error.message);
    }
}

async function deleteTemplate(templateId) {
    if (!confirm('ç¡®å®šè¦åˆ é™¤æ­¤æ¨¡æ¿å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚')) {
        return;
    }

    try {
        const response = await fetch(`/api/global-master-templates/${templateId}`, {
            method: 'DELETE'
        });

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.detail || 'Failed to delete template');
        }

        // å¦‚æœåˆ é™¤åå½“å‰é¡µæ²¡æœ‰æ•°æ®ä¸”ä¸æ˜¯ç¬¬ä¸€é¡µï¼Œåˆ™å›åˆ°ä¸Šä¸€é¡µ
        const shouldGoToPrevPage = templates.length === 1 && currentPage > 1;
        loadTemplates(shouldGoToPrevPage ? currentPage - 1 : currentPage);
        alert('æ¨¡æ¿åˆ é™¤æˆåŠŸï¼');
    } catch (error) {
        console.error('Error deleting template:', error);
        alert('åˆ é™¤æ¨¡æ¿å¤±è´¥: ' + error.message);
    }
}

async function previewTemplateById(templateId) {
    try {
        const response = await fetch(`/api/global-master-templates/${templateId}/preview`);
        if (!response.ok) {
            throw new Error('Failed to load template preview');
        }

        const data = await response.json();
        showPreview(data.html_template);
    } catch (error) {
        console.error('Error loading template preview:', error);
        alert('åŠ è½½é¢„è§ˆå¤±è´¥: ' + error.message);
    }
}

function showPreview(htmlContent) {
    const modal = document.getElementById('previewModal');
    const frame = document.getElementById('previewFrame');
    const container = document.getElementById('previewFrameContainer');

    // åœ¨æ¨¡æ€é¢„è§ˆä¸­åŒæ ·æ›¿æ¢å¸¸è§å ä½ç¬¦ï¼Œé¿å…æ˜¾ç¤ºåŸå§‹ {{ var }}
    let previewHtml = htmlContent || '';
    const dateStr = new Date().toLocaleDateString();
    const replacements = [
        ['title', 'ç¤ºä¾‹æ ‡é¢˜'],
        ['main_title', 'ç¤ºä¾‹æ ‡é¢˜'],
        ['main_heading', 'ç¤ºä¾‹æ ‡é¢˜'],
        ['heading', 'ç¤ºä¾‹æ ‡é¢˜'],
        ['subtitle', 'å­æ ‡é¢˜'],
        ['subheading', 'å­æ ‡é¢˜'],
        ['content', 'è¿™æ˜¯æ¨¡æ¿é¢„è§ˆå†…å®¹'],
        ['body', 'è¿™æ˜¯æ¨¡æ¿é¢„è§ˆå†…å®¹'],
        ['author', 'FlowSlide'],
        ['company_name', 'Your Company'],
        ['username', 'User'],
        ['date', dateStr],
        ['footer', 'FlowSlide é¢„è§ˆ'],
        ['page', '1'],
        ['page_number', '1'],
        ['slide_number', '1'],
        ['current_slide', '1'],
        ['total_slides', '1'],
        ['total_pages', '1'],
        ['theme_color', '#4f46e5'],
        ['background_color', '#ffffff'],
        ['logo_url', '']
    ];
    replacements.forEach(([key, value]) => {
        try {
            const re = new RegExp(`\\{\\{\\s*${key}\\s*\\}\\}`,'g');
            previewHtml = previewHtml.replace(re, String(value));
        } catch (e) { /* noop */ }
    });

    // å¦‚æœç¼ºå°‘åŸºç¡€ç»“æ„ï¼Œåˆ™è¡¥é½ï¼Œé¿å…ç©ºç™½
    if (!previewHtml.includes('<!DOCTYPE') && !previewHtml.includes('<html')) {
        // Add a small safety CSS block to ensure the body and likely slide containers have a minimum
        // size and overflow hidden so modal cover-scaling works reliably.
        const safetyCss = `<style>
            html, body { margin:0; padding:0; background: transparent; }
            body { min-width: 320px; min-height: 240px; box-sizing: border-box; overflow: hidden; }
            /* If the template has a top header-only layout, prefer centering the main content */
            .slide, .ppt-slide, .page, #root, .slide-content { box-sizing: border-box; min-width: 320px; min-height: 240px; }
        </style>`;
        // Stronger modal preview CSS: force html/body and direct children to fill the iframe viewport
        const modalPreviewInjectCSS = `<style>
            html, html * { box-sizing: border-box !important; }
            html, body { width:100% !important; height:100% !important; min-width:100% !important; min-height:100% !important; margin:0 !important; padding:0 !important; overflow:hidden !important; display:block !important; }
            body > * { width:100% !important; height:100% !important; min-width:100% !important; min-height:100% !important; display:block !important; box-sizing:border-box !important; }
            .slide, .ppt-slide, #root, .page, .slide-content, .container, .wrap, .content, main, section, article, .cols, .row, .column, .col, .inner {
                width:100% !important; height:100% !important; min-width:100% !important; min-height:100% !important; max-width:none !important; max-height:none !important; display:block !important; box-sizing:border-box !important;
            }
            img, svg { max-width:100% !important; height:auto !important; }
        </style>`;

    const previewInjectScript = `<script>(function(){try{function __fs_fix(){try{document.documentElement.style.width='100%';document.documentElement.style.height='100%';document.body.style.width='100%';document.body.style.height='100%';}catch(e){}try{window.dispatchEvent(new Event('resize'));}catch(e){}setTimeout(function(){try{window.dispatchEvent(new Event('resize'));}catch(e){}},80);setTimeout(function(){try{window.dispatchEvent(new Event('resize'));}catch(e){}},300);setTimeout(function(){try{if(window && window.initSlides) try{window.initSlides();}catch(e){}; if(window && window.recalcLayout) try{window.recalcLayout();}catch(e){} }catch(e){}},500);}if(document.readyState==='complete'){__fs_fix();}else{window.addEventListener('load', __fs_fix);setTimeout(__fs_fix, 120);} }catch(e){} })()<\/script>`;

        previewHtml = `<!DOCTYPE html>\n<html>\n<head>\n<meta charset="UTF-8">\n<meta name="viewport" content="width=device-width, initial-scale=1.0">\n${safetyCss}\n${modalPreviewInjectCSS}\n</head>\n<body>\n${previewHtml}\n</body>\n</html>`;
    }

    // Also attempt to inject modalPreviewInjectCSS if the template already contains a <head> so rules apply
        try {
        if (typeof modalPreviewInjectCSS !== 'undefined' && /<head[^>]*>/i.test(previewHtml)) {
            previewHtml = previewHtml.replace(/<head[^>]*>/i, function(m) { return m + modalPreviewInjectCSS + previewInjectScript; });
        } else if (typeof modalPreviewInjectCSS !== 'undefined' && /<html[^>]*>/i.test(previewHtml)) {
            previewHtml = previewHtml.replace(/<html([^>]*)>/i, function(m) { return m + '<head>' + modalPreviewInjectCSS + previewInjectScript + '</head>'; });
        }
    } catch (e) { /* noop */ }

    // Create blob URL for the HTML content
    const blob = new Blob([previewHtml], { type: 'text/html' });
    const url = URL.createObjectURL(blob);
    try {
        if (!window.__previewLoadState) window.__previewLoadState = { abortControllers: [], blobUrls: [] };
        if (Array.isArray(window.__previewLoadState.blobUrls)) window.__previewLoadState.blobUrls.push(url);
    } catch (e) { /* noop */ }

    frame.src = url;
    // Show modal and adjust scale to fit viewport
    modal.style.display = 'grid';
    // prefer 'center' alignment for modal; save a modal-specific key
    window.__previewAlignments = window.__previewAlignments || new Map();
    window.__previewAlignments.set('modal', 'center');
    // Once iframe content loads, measure and apply cover scaling similar to card previews
    frame.onload = function() {
        try {
            applyCoverScaleGeneric(frame);
        } catch (e) { /* noop */ }
        // also run the existing viewport adjustment
        setTimeout(adjustPreviewScale, 0);
    };
    // attempt an initial scale soon after setting src
    setTimeout(function(){ try { applyCoverScaleGeneric(frame); } catch(e){} }, 80);

    // Clean up the blob URL after a delay; also remove from global tracking
    setTimeout(() => {
        try { URL.revokeObjectURL(url); } catch(e){}
        try {
            if (window.__previewLoadState && Array.isArray(window.__previewLoadState.blobUrls)) {
                const idx = window.__previewLoadState.blobUrls.indexOf(url);
                if (idx !== -1) window.__previewLoadState.blobUrls.splice(idx, 1);
            }
        } catch(e){}
    }, 1000);
}

// è‡ªåŠ¨æ ¹æ®å¯ç”¨ç©ºé—´ç¼©æ”¾é¢„è§ˆï¼Œä½¿å…¶å°½å¯èƒ½å æ»¡é«˜åº¦
function adjustPreviewScale() {
    const modal = document.getElementById('previewModal');
    const content = modal ? modal.querySelector('.modal-content') : null;
    const header = modal ? modal.querySelector('.modal-header') : null;
    const body = modal ? modal.querySelector('.modal-body') : null;
    const container = document.getElementById('previewFrameContainer');
    const frame = document.getElementById('previewFrame');
    if (!modal || !content || !body || !container || !frame) return;

    // è®¡ç®—å¯ç”¨å®½é«˜
    const contentRect = content.getBoundingClientRect();
    const headerRect = header ? header.getBoundingClientRect() : { height: 64 };
    const bodyStyle = window.getComputedStyle(body);
    const bodyPaddingV = parseFloat(bodyStyle.paddingTop) + parseFloat(bodyStyle.paddingBottom);
    const bodyPaddingH = parseFloat(bodyStyle.paddingLeft) + parseFloat(bodyStyle.paddingRight);

    const availableWidth = contentRect.width - bodyPaddingH - 8; // ä½™é‡
    const availableHeight = contentRect.height - (headerRect.height || 64) - bodyPaddingV - 8;

    // è‡ªç„¶å°ºå¯¸ï¼ˆç”±æ¨¡æ¿å®½é«˜å®šä¹‰ï¼‰
    // å¼ºåˆ¶ 16:9 æ¯”ä¾‹
    const naturalW = 960;
    const naturalH = 540;
    frame.setAttribute('width', naturalW);
    frame.setAttribute('height', naturalH);
    if (!naturalW || !naturalH) return;

    // Set container size to available area and let the generic cover scaler compute and apply iframe transform
    container.style.width = availableWidth + 'px';
    container.style.height = availableHeight + 'px';
    container.style.overflow = 'hidden';
    container.style.display = 'flex';
    container.style.alignItems = 'center';
    container.style.justifyContent = 'center';

    // Delegate actual frame scaling/positioning to applyCoverScaleGeneric so modal matches card behavior
    try {
        applyCoverScaleGeneric(frame);
    } catch (e) { /* noop */ }
}

// çª—å£å¤§å°å˜åŒ–æ—¶é‡æ–°è®¡ç®—ç¼©æ”¾
window.addEventListener('resize', function(){
    const modal = document.getElementById('previewModal');
    if (modal && modal.style.display && modal.style.display !== 'none') {
        adjustPreviewScale();
    }
});

// ä½¿é¢„è§ˆæ¨¡æ€æ¡†å³ä¸Šè§’çš„â€œå‰â€æŒ‰é’®ç”Ÿæ•ˆ
function closePreviewModal() {
    const modal = document.getElementById('previewModal');
    const frame = document.getElementById('previewFrame');
    if (frame) {
        try { frame.src = 'about:blank'; } catch (e) {}
    }
    if (modal) modal.style.display = 'none';
}

// Pagination functions
    function measureAndApply() {
        attempts++;
        // Defer actual measurement & style writes to idle time to avoid blocking
        const doMeasure = function() {
            let contentW = parseInt(frame.getAttribute('width')) || 1280;
            let contentH = parseInt(frame.getAttribute('height')) || 720;
            let measured = false;
            try {
                const doc = frame.contentDocument || frame.contentWindow.document;
                if (doc) {
                    const body = doc.body || doc.documentElement;
                    const bRect = body.getBoundingClientRect();
                    // prefer measuring a common slide container if present
                    const slideSelectors = ['.slide', '.ppt-slide', '#root', '.page', '.slide-content'];
                    for (const sel of slideSelectors) {
                        try {
                            const el = doc.querySelector(sel);
                            if (el) {
                                const r = el.getBoundingClientRect();
                                if (r.width > 20 && r.height > 20) {
                                    contentW = Math.max(contentW, Math.round(r.width));
                                    contentH = Math.max(contentH, Math.round(r.height));
                                    measured = true;
                                    break;
                                }
                            }
                        } catch (innerSelE) { /* noop */ }
                    }

                    if (!measured) {
                        contentW = Math.max(contentW, Math.abs(bRect.width) || contentW);
                        contentH = Math.max(contentH, Math.abs(bRect.height) || contentH);
                        // if body is too small (e.g., only header strip), try scroll sizes
                        contentW = Math.max(contentW, body.scrollWidth || 0, body.offsetWidth || 0);
                        contentH = Math.max(contentH, body.scrollHeight || 0, body.offsetHeight || 0);
                    }

                    // Clamp sizes to avoid extreme values
                    contentW = Math.max(320, Math.min(4000, contentW));
                    contentH = Math.max(200, Math.min(3000, contentH));

                    // Apply sizes (style writes) - do this last to minimize layout thrash
                    try {
                        frame.style.width = contentW + 'px';
                        frame.style.height = contentH + 'px';
                    } catch (e) { /* noop */ }
                }
            } catch (e) {
                // cross-origin or other access denied - keep fallback sizes
            }

            // If measured size seems like just a small header (height < 200) and we have attempts left, retry after a short delay
            try {
                const bH = parseInt(frame.style.height) || 0;
                if ((bH < 200 || (parseInt(frame.style.width) || 0) < 200) && attempts < maxAttempts) {
                    setTimeout(measureAndApply, 120 * attempts);
                }
            } catch(e) { if (attempts < maxAttempts) setTimeout(measureAndApply, 120 * attempts); }
        };

        if (window.requestIdleCallback) {
            try { window.requestIdleCallback(doMeasure, { timeout: 200 }); }
            catch(e) { setTimeout(doMeasure, 0); }
        } else {
            setTimeout(doMeasure, 0);
        }
    }

function updatePagination() {
    const paginationContainer = document.getElementById('paginationContainer');
    const paginationInfo = document.getElementById('paginationInfo');
    const prevBtn = document.getElementById('prevPageBtn');
    const nextBtn = document.getElementById('nextPageBtn');
    const pageNumbers = document.getElementById('pageNumbers');

    if (!paginationContainer) return;
    if (totalCount > 0) {
        paginationContainer.style.display = 'block';
    } else {
        paginationContainer.style.display = 'none';
        return;
    }

    const startItem = totalCount > 0 ? ((currentPage - 1) * pageSize) + 1 : 0;
    const endItem = Math.min(currentPage * pageSize, totalCount);
    if (paginationInfo) paginationInfo.textContent = `æ˜¾ç¤ºç¬¬ ${startItem}-${endItem} é¡¹ï¼Œå…± ${totalCount} é¡¹`;

    if (prevBtn) prevBtn.disabled = currentPage <= 1;
    if (nextBtn) nextBtn.disabled = currentPage >= totalPages;

    if (!pageNumbers) return;
    pageNumbers.innerHTML = '';

    const visibleCount = 7;
    const half = Math.floor(visibleCount / 2);
    let startPage = Math.max(1, currentPage - half);
    let endPage = Math.min(totalPages, startPage + visibleCount - 1);
    if (endPage - startPage < visibleCount - 1) startPage = Math.max(1, endPage - visibleCount + 1);

    if (startPage > 1) {
        addPageNumber(pageNumbers, 1);
        if (startPage > 2) addEllipsis(pageNumbers);
    }

    for (let i = startPage; i <= endPage; i++) addPageNumber(pageNumbers, i);

    if (endPage < totalPages) {
        if (endPage < totalPages - 1) addEllipsis(pageNumbers);
        addPageNumber(pageNumbers, totalPages);
    }
}

function addPageNumber(container, pageNum) {
    const pageBtn = document.createElement('button');
    pageBtn.className = `page-number ${pageNum === currentPage ? 'active' : ''}`;
    pageBtn.textContent = pageNum;
    pageBtn.onclick = () => loadTemplates(pageNum);
    container.appendChild(pageBtn);
}

function addEllipsis(container) {
    const ellipsis = document.createElement('span');
    ellipsis.className = 'page-number disabled';
    ellipsis.textContent = '...';
    container.appendChild(ellipsis);
}

function handleSearch() {
    currentSearch = document.getElementById('searchInput').value.trim();
    loadTemplates(1); // Reset to first page when searching
}

function handleTagFilter() {
    currentTag = document.getElementById('tagFilter').value;
    loadTemplates(1); // Reset to first page when filtering
}

function handlePageSizeChange() {
    pageSize = parseInt(document.getElementById('pageSizeSelect').value);
    loadTemplates(1); // Reset to first page when changing page size
}

function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}
</script>

<script src="/static/js/global_master_templates.js"></script>
{% endblock %}
